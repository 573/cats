<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="generator" content="AsciiDoc 8.6.9">
<title>Category Theory abstractions for Clojure</title>
<link rel="stylesheet" href="static/niwi.css" type="text/css">
<link rel="stylesheet" href="static/pygments.css" type="text/css">


<script type="text/javascript" src="static/asciidoc.js"></script>
<script type="text/javascript" src="static/niwi.js"></script>
<script type="text/javascript">
/*<![CDATA[*/
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article" style="max-width:960px">
<div id="header">
<h1>Category Theory abstractions for Clojure</h1>
<span id="author">Andrey Antukh &amp; Alejandro GÃ³mez</span><br>
<span id="revnumber">version 0.1.0,</span>
<span id="revdate">2014-06-06</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>Category Theory abstractions for Clojure.</p></div>
<div class="sect2">
<h3 id="_philosophy">Philosophy</h3>
<div class="paragraph"><p>Four most important rules:</p></div>
<div class="ulist"><ul>
<li>
<p>
Beautiful is better than ugly
</p>
</li>
<li>
<p>
Explicit is better than implicit
</p>
</li>
<li>
<p>
Simple is better than complex
</p>
</li>
<li>
<p>
Readability counts
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_project_maturity">Project Maturity</h2>
<div class="sectionbody">
<div class="paragraph"><p>Since <em>cats</em> is a young project there can be some <a href="codox/index.html#id">API</a>
breakage.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_install">Install</h2>
<div class="sectionbody">
<div class="paragraph"><p>This section covers installing <em>cats</em>.</p></div>
<div class="sect2">
<h3 id="_requirements">Requirements</h3>
<div class="paragraph"><p><em>cats</em> has support for these jvm versions:</p></div>
<div class="ulist"><ul>
<li>
<p>
JDK7
</p>
</li>
<li>
<p>
JDK8
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_leiningen">Leiningen</h3>
<div class="paragraph"><p>The simplest way to use <em>cats</em> in a Clojure project is by including
it as a dependency in your <strong><em>project.clj</em></strong>:</p></div>
<div class="listingblock">
<div class="title"><em>in project.clj</em></div>
<div class="content"><div class="highlight"><pre><span class="p">[</span><span class="nv">cats</span> <span class="s">&quot;0.1.0-SNAPSHOT&quot;</span><span class="p">]</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_maven">Maven</h3>
<div class="paragraph"><p>Also, you can use it with maven. First, add the clojars repository:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="nt">&lt;repository&gt;</span>
    <span class="nt">&lt;id&gt;</span>clojars.org<span class="nt">&lt;/id&gt;</span>
    <span class="nt">&lt;url&gt;</span>http://clojars.org/repo<span class="nt">&lt;/url&gt;</span>
<span class="nt">&lt;/repository&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Then for cats:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="nt">&lt;dependency&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>cats<span class="nt">&lt;/groupId&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>cats<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;version&gt;</span>0.1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_get_the_code">Get the Code</h3>
<div class="paragraph"><p><em>cats</em> is opensource and is entirely developed on <a href="https://github.com/niwibe/cats">github</a>.</p></div>
<div class="paragraph"><p>You can clone the public repository with this command:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre>git clone https://github.com/niwibe/cats
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_why_another_library">Why another library?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Because cats library:</p></div>
<div class="ulist"><ul>
<li>
<p>
targets both most used clojure implementations:  <strong>Clojure (jvm)</strong> and <strong>ClojureScript(js)</strong>
</p>
</li>
<li>
<p>
targets to have the most simple implementation for supported abstractions.
</p>
</li>
<li>
<p>
targets to have more abstractions that simple monad.
</p>
</li>
<li>
<p>
has documentation as first class citizen.
</p>
</li>
<li>
<p>
licensed under permisive license (in comparison with other libraries): BSD (2-Clause)
</p>
</li>
</ul></div>
<div class="paragraph"><p>With differences with other existing libraries:</p></div>
<div class="ulist"><ul>
<li>
<p>
The official monads library <span class="monospaced">algo.monads</span> is very good, but its approach for modeling
  is slighty limited (as example, you always should specify that monad you want use instead
  relying on the type). And obviously because it only has monads.
</p>
</li>
<li>
<p>
Fluokitten is the best library that we found, but the future of it is uncertain. One big
  difference with fluokitten library is that <span class="monospaced">cats</span> not intends extend every clojure type
  with monadic protocols, for obvious reason of monad, functor and applicative represents
  context/wrapper type and it not make sense implement Functor protocol for <span class="monospaced">java.lang.String</span>.
</p>
</li>
<li>
<p>
<span class="monospaced">bwo/monads</span> is the last monads library. It is completely undocumented and its implementation
  has much innecesary complexity.
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect1">
<h2 id="_abstractions_reference">Abstractions Reference</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_functor">Functor</h3>
<div class="paragraph"><p>The Functor represents some sort of "computational context".</p></div>
<div class="listingblock">
<div class="title">This is aspect of Functor protocol</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Functor</span>
  <span class="p">(</span><span class="nf">fmap</span> <span class="p">[</span><span class="nv">fv</span> <span class="nv">f</span><span class="p">]</span>
    <span class="s">&quot;Applies function f to the value(s) inside</span>
<span class="s">    the context of the functor fv.&quot;</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="monospaced">fmap</span> takes one wrapped value in functor context fv (ex: <span class="monospaced">Just 2</span>) and plain function,
unwraps the value and apply a function to plain value returning it wrapped in a new context
of <strong>the same type</strong> of the first argument.</p></div>
<div class="paragraph"><p>Some examples can explain it better:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">cats.core</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">])</span>
<span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">cats.types</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">])</span>

<span class="p">(</span><span class="nf">fmap</span> <span class="nb">inc </span><span class="p">(</span><span class="nf">just</span> <span class="mi">1</span><span class="p">))</span>
<span class="c1">;; =&gt; #&lt;Just [2]&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Same example but applying function over Nothing:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">fmap</span> <span class="nb">inc </span><span class="p">(</span><span class="nf">nothing</span><span class="p">))</span>
<span class="c1">;; =&gt; #&lt;Nothing &gt;</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>The real fmap signature is <span class="monospaced">(a -&gt; b) -&gt; f a -&gt; f b</span> that can be traslated to clojure <span class="monospaced">[f fv]</span>.</p></div>
<div class="paragraph"><p>The changed order on protocol parameters definition is required because of clojure&#8217;s protocols
limitation that only allow dispatching on first argument.</p></div>
<div class="paragraph"><p>You should never use protocol function directly. For it, <span class="monospaced">cats.core/fmap</span> exists, and it has
the correct signature.</p></div>
<div class="paragraph"><p>All examples of this documentation uses <span class="monospaced">cats.core/fmap</span> instead of function defined in the
protocol.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Some of native clojure types, like Vector, also implements the Functor protocol and can
work like functor context/container:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">fmap</span> <span class="nb">inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;; =&gt; [2 3 4]</span>
</pre></div></div></div>
<div class="paragraph"><p>The main difference of previous example with default clojure map, is that the clojure
map works with seqs and it not respects the input container:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nb">map inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="c1">;; =&gt; (2 3 4)</span>
</pre></div></div></div>
<div class="paragraph"><p>You can see more information and examples of clojure types that implements this protocol
on the last section of this documentation.</p></div>
</div>
<div class="sect2">
<h3 id="_applicative_functor">Applicative Functor</h3>
<div class="paragraph"><p>Represents an abstraction lying in between Functor and Monad in expressivity.</p></div>
<div class="listingblock">
<div class="title">Applicative protocol definition</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Applicative</span>
  <span class="p">(</span><span class="nf">fapply</span> <span class="p">[</span><span class="nv">af</span> <span class="nv">av</span><span class="p">]</span>
    <span class="s">&quot;Applies the function(s) inside ag&#39;s context to the value(s)</span>
<span class="s">     inside av&#39;s context while preserving the context.&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">pure</span> <span class="p">[</span><span class="nv">ctx</span> <span class="nv">v</span><span class="p">]</span>
    <span class="s">&quot;Takes any context monadic value ctx and any value v, and puts</span>
<span class="s">     the value v in the most minimal context of same type of ctx&quot;</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>With the same idea of data inside a context (like <span class="monospaced">Functor</span>), what is happens if a wrapped value is
one function/computation? Applicative functors works like plain functors but additionally
can apply function wrapped in some context similar to input value.</p></div>
<div class="paragraph"><p>Let see one example:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="kd">defn </span><span class="nv">make-greeter</span>
  <span class="p">[</span><span class="o">^</span><span class="nv">String</span> <span class="nv">lang</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">condp</span> <span class="nb">= </span><span class="nv">lang</span>
    <span class="s">&quot;es&quot;</span> <span class="p">(</span><span class="nf">just</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hola &quot;</span> <span class="nv">name</span><span class="p">)))</span>
    <span class="s">&quot;en&quot;</span> <span class="p">(</span><span class="nf">just</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">name</span><span class="p">]</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello &quot;</span> <span class="nv">name</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">nothing</span><span class="p">)))</span>

<span class="p">(</span><span class="nf">fapply</span> <span class="p">(</span><span class="nf">make-greeter</span> <span class="s">&quot;es&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">just</span> <span class="s">&quot;Alex&quot;</span><span class="p">))</span>
<span class="c1">;; =&gt; #&lt;Just [Hola Alex]&gt;</span>

<span class="p">(</span><span class="nf">fapply</span> <span class="p">(</span><span class="nf">make-greeter</span> <span class="s">&quot;en&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">just</span> <span class="s">&quot;Alex&quot;</span><span class="p">))</span>
<span class="c1">;; =&gt; #&lt;Just [Hello Alex]&gt;</span>

<span class="p">(</span><span class="nf">fapply</span> <span class="p">(</span><span class="nf">make-greeter</span> <span class="s">&quot;it&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">just</span> <span class="s">&quot;Alex&quot;</span><span class="p">))</span>
<span class="c1">;; =&gt; #&lt;Nothing &gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Moreover, applicative functor protocol comes with an other function: <span class="monospaced">pure</span>. The main purpose of
it, is given any value in a context and new value, wraps the new value in a minimal context of same
type as first argument.</p></div>
<div class="paragraph"><p>To understand it better, see some examples:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">pure</span> <span class="p">(</span><span class="nf">just</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">;; =&gt; #&lt;Just [5]&gt;</span>

<span class="p">(</span><span class="nf">pure</span> <span class="p">(</span><span class="nb">right </span><span class="ss">:foo</span><span class="p">)</span> <span class="ss">:bar</span><span class="p">)</span>
<span class="c1">;; =&gt; #&lt;Either [:bar :right]&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>The real purpose of this function you will see in a following <span class="monospaced">Monad</span> section.</p></div>
</div>
<div class="sect2">
<h3 id="_monad">Monad</h3>
<div class="paragraph"><p>Monads are the most discussed programming concept to come from category theory. Like functors and
applicatives, monads deal with data in contexts.</p></div>
<div class="paragraph"><p>Additionaly, monads can also transform context by unwrapping data, applying functions to it and
put new value in a completely different context.</p></div>
<div class="listingblock">
<div class="title">This is aspect of Monad protocol</div>
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">Monad</span>
  <span class="s">&quot;Incomplete monad type definition.&quot;</span>
  <span class="p">(</span><span class="nf">bind</span> <span class="p">[</span><span class="nv">mv</span> <span class="nv">f</span><span class="p">]</span> <span class="s">&quot;Applies the function f to the value(s) inside mv&#39;s context.&quot;</span><span class="p">))</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">In diference with haskel type class, <em>cats</em> protocol only defines one method: <span class="monospaced">bind</span>. Other
related methods like <span class="monospaced">return</span> are defined as auxiliar functions in <span class="monospaced">cats.core</span> namespace.</td>
</tr></table>
</div>
<div class="paragraph"><p><span class="monospaced">bind</span> function, takes a monadic value (any container that implements a <span class="monospaced">Monad</span> protocol) and one
function, applies the function with unwrapped value as first parameter and return a result. In this
case, is a function respoisability of function wrap the result in a corresponding context.</p></div>
<div class="paragraph"><p>One of the key features of bind function, that everythig insined a monad context known the context
type. Having this, if you apply some computation over a monad and you want return the result
in the same container context but you don&#8217;t know that contaier is it, you can use <span class="monospaced">return</span> or <span class="monospaced">pure</span>
function for it.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">bind</span> <span class="p">(</span><span class="nf">just</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">v</span><span class="p">]</span> <span class="p">(</span><span class="nf">return</span> <span class="p">(</span><span class="nb">inc </span><span class="nv">v</span><span class="p">))))</span>
<span class="c1">;; =&gt; #&lt;Just [2]&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="monospaced">return</span> or <span class="monospaced">pure</span> function with one argument, try takes a context value from dynamic scope collected
internaly by <span class="monospaced">bind</span> function, so that, you can not use them with one argument out of <span class="monospaced">bind</span> context.</p></div>
<div class="paragraph"><p>And finally, for make more powerful monadic compositions, <em>cats</em> comes with <span class="monospaced">mlet</span> macro that
if you coming from haskell, represents a <span class="monospaced">do-syntax</span>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">mlet</span> <span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nf">just</span> <span class="mi">1</span><span class="p">)</span>
       <span class="nv">y</span> <span class="p">(</span><span class="nf">just</span> <span class="mi">2</span><span class="p">)</span>
       <span class="nv">z</span> <span class="p">(</span><span class="nf">just</span> <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span><span class="p">))]</span>
  <span class="p">(</span><span class="nf">return</span> <span class="nv">z</span><span class="p">))</span>
<span class="c1">;; =&gt; #&lt;Just [3]&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>TODO: document other more advanced options like <span class="monospaced">:let</span> and <span class="monospaced">:when</span> in a <span class="monospaced">mlet</span> context.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_data_types_reference">Data Types Reference</h2>
<div class="sectionbody">
<div class="paragraph"><p>We talked about values in a context, but that is a context? Context per se is any value that
wraps an other value inside.</p></div>
<div class="sect2">
<h3 id="_maybe">Maybe</h3>
<div class="paragraph"><p>Two most common wrapper is "Maybe" (commonly named Optional on not functional programming
languages).</p></div>
<div class="paragraph"><p>Maybe/Optional is a polymorphic type that represents encapsulation of an optional value; e.g. it is
used as the return type of functions which may or may not return a meaningful value when they
are applied. It consists of either an empty constructor (called None or Nothing), or a constructor
encapsulating the original data type A (written Just A or Some A).</p></div>
<div class="paragraph"><p><em>cats</em>, implements two constructors:</p></div>
<div class="ulist"><ul>
<li>
<p>
<span class="monospaced">(just v)</span>: represents just a value in a context.
</p>
</li>
<li>
<p>
<span class="monospaced">(nothing)</span>: represents a failure or null.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">cats.types</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">])</span>
<span class="p">(</span><span class="nf">just</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">;; =&gt; #&lt;Just [1]&gt;</span>
<span class="p">(</span><span class="nf">nothing</span><span class="p">)</span>
<span class="c1">;; =&gt; #&lt;Nothing &gt;</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Maybe types are: Functors, Applicative Functors and Monads</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_either">Either</h3>
<div class="paragraph"><p>Either is an other type that represents a result of computation, but in contrast with maybe
it can return something with failed computation result.</p></div>
<div class="paragraph"><p>In <em>cats</em> library it has two constructors:</p></div>
<div class="ulist"><ul>
<li>
<p>
<span class="monospaced">(left v)</span>: represents a failure.
</p>
</li>
<li>
<p>
<span class="monospaced">(right v)</span>: represents a successful result.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">cats.types</span> <span class="ss">:refer</span> <span class="ss">:all</span><span class="p">])</span>

<span class="p">(</span><span class="nb">right </span><span class="ss">:valid-value</span><span class="p">)</span>
<span class="c1">;; =&gt; #&lt;Right [:valid-value :right]&gt;</span>

<span class="p">(</span><span class="nb">left </span><span class="s">&quot;Error message&quot;</span><span class="p">)</span>
<span class="c1">;; =&gt; #&lt;Either [Error message :left]&gt;</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">Either is also (like Maybe) Functor, Applicative Functor and Monad.</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_clojure_types">Clojure Types</h2>
<div class="sectionbody">
<div class="paragraph"><p>Besides the own types, some colojure types has implementations for previously explained
category theory abstractions.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">With contrast with other similar libraries in clojure, <em>cats</em> not intends extend clojure types
that not acts like containers. As example, clojure keywords are values but can not be containers, so
that, their should not extend previously explained protocols.</td>
</tr></table>
</div>
<div class="sect2">
<h3 id="_vector">Vector</h3>
<div class="paragraph"><p>TODO</p></div>
</div>
<div class="sect2">
<h3 id="_list">List</h3>
<div class="paragraph"><p>TODO</p></div>
</div>
<div class="sect2">
<h3 id="_set">Set</h3>
<div class="paragraph"><p>TODO</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license">License</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre>Copyright (c) 2014, Andrey Antukh
Copyright (c) 2014, Alejandro GÃ³mez

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre></div></div></div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Version 0.1.0<br>
Last updated 2014-06-29 01:04:43 CEST
</div>
</div>
</body>
</html>
