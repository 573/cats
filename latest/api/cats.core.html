<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>cats.core documentation</title></head><body><header><section class="title"><h1><a href="index.html">Cats Api Documentation</a></h1></section><small>Version: 2.0.0</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cats</span></div></div></li><li class="depth-2 branch"><a href="cats.builtin.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builtin</span></div></a></li><li class="depth-2 branch"><a href="cats.context.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>context</span></div></a></li><li class="depth-2 branch current"><a href="cats.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="cats.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>labs</span></div></div></li><li class="depth-3 branch"><a href="cats.labs.channel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>channel</span></div></a></li><li class="depth-3 branch"><a href="cats.labs.manifold.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>manifold</span></div></a></li><li class="depth-3 branch"><a href="cats.labs.promise.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>promise</span></div></a></li><li class="depth-3"><a href="cats.labs.test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>monad</span></div></div></li><li class="depth-3 branch"><a href="cats.monad.either.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>either</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.exception.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exception</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.identity.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>identity</span></div></a></li><li class="depth-3"><a href="cats.monad.maybe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maybe</span></div></a></li><li class="depth-2 branch"><a href="cats.protocols.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2"><a href="cats.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">cats.core</h2><div class="doc"><div class="markdown"><p>Category Theory abstractions for Clojure</p></div></div><div class="public anchor" id="var--.3E.3D"><h3><a href="#var--.3E.3D">-&gt;=</a></h3><h4 class="type">macro</h4><div class="usage"><code>(-&gt;= expr &amp; forms)</code></div><div class="doc"><div class="markdown"><p>Like <code>-&gt;</code>, but with monadic binding instead of pure application. A mnemonic for the name is a pun on <code>&gt;&gt;=</code>, the monadic bind operator, and clojure&rsquo;s regular arrow macros.</p><p>You can think of it as generalizing the <code>some-&gt;</code> thread macro to all Monads instead of just Maybe.</p><p>Alternatively, if you think of the regular thread macro as sugar for <code>let</code>:</p><p>(-&gt; :a b (c (other args)) d) =&gt; (let [res (b :a)  res (c res (other args))  res (d res)]  res)</p><p>Then <code>-&gt;=</code> is sugar for cats.core/mlet:</p><p>(-&gt;= m-a b (c (other args)) d) (mlet [res m-a  res (c res (other args))  res (d res)]  (return res))</p><p>Note that extra args in this context are assumed pure, and will be evaluated along with the function itself; this also matches the behavior of <code>some-&gt;</code> wrt extra args.</p><p>Threading through pure functions is somewhat awkward, but can be done:</p><p>(-&gt;= m-a  monadic-fn  (-&gt; pure-fn  other-pure-fn  m/return)  other-monadic-fn)</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L552">view source</a></div></div><div class="public anchor" id="var--.3E.3E.3D"><h3><a href="#var--.3E.3E.3D">-&gt;&gt;=</a></h3><h4 class="type">macro</h4><div class="usage"><code>(-&gt;&gt;= expr &amp; forms)</code></div><div class="doc"><div class="markdown"><p>Like -&gt;&gt;, but with monadic binding instead of pure application. See <code>cats.labs.sugar/-&gt;=</code> for more in-depth discussion.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L597">view source</a></div></div><div class="public anchor" id="var-.3C.24.3E"><h3><a href="#var-.3C.24.3E">&lt;$&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A Haskell-style <code>fmap</code> alias.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L872">view source</a></div></div><div class="public anchor" id="var-.3C*.3E"><h3><a href="#var-.3C*.3E">&lt;*&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A Haskell-style <code>fapply</code> alias.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L876">view source</a></div></div><div class="public anchor" id="var-.3C.3D.3C"><h3><a href="#var-.3C.3D.3C">&lt;=&lt;</a></h3><div class="usage"><code>(&lt;=&lt; mg mf x)</code></div><div class="doc"><div class="markdown"><p>Right-to-left composition of monads. Same as <code>&gt;=&gt;</code> with its first two arguments flipped.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L915">view source</a></div></div><div class="public anchor" id="var-.3C.3E"><h3><a href="#var-.3C.3E">&lt;&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L930">view source</a></div></div><div class="public anchor" id="var-.3D.3C.3C"><h3><a href="#var-.3D.3C.3C">=&lt;&lt;</a></h3><div class="usage"><code>(=&lt;&lt; f mv)</code></div><div class="doc"><div class="markdown"><p>Same as the two argument version of <code>&gt;&gt;=</code> but with the arguments flipped.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L901">view source</a></div></div><div class="public anchor" id="var-.3E.3D.3E"><h3><a href="#var-.3E.3D.3E">&gt;=&gt;</a></h3><div class="usage"><code>(&gt;=&gt; mf mg x)</code></div><div class="doc"><div class="markdown"><p>Left-to-right composition of monads.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L907">view source</a></div></div><div class="public anchor" id="var-.3E.3E"><h3><a href="#var-.3E.3E">&gt;&gt;</a></h3><div class="usage"><code>(&gt;&gt; mv mv&apos;)</code><code>(&gt;&gt; mv mv&apos; &amp; mvs)</code></div><div class="doc"><div class="markdown"><p>Perform a Haskell-style left-associative bind, ignoring the values produced by the monadic computations.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L893">view source</a></div></div><div class="public anchor" id="var-.3E.3E.3D"><h3><a href="#var-.3E.3E.3D">&gt;&gt;=</a></h3><div class="usage"><code>(&gt;&gt;= mv f)</code><code>(&gt;&gt;= mv f &amp; fs)</code></div><div class="doc"><div class="markdown"><p>Perform a Haskell-style left-associative bind.</p><p>Let&rsquo;s see it in action:</p>
<pre><code>(&gt;&gt;= (just 1) (comp just inc) (comp just inc))
;; =&gt; #&lt;Just [3]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L880">view source</a></div></div><div class="public anchor" id="var-alet"><h3><a href="#var-alet">alet</a></h3><h4 class="type">macro</h4><div class="usage"><code>(alet bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Applicative composition macro similar to Clojure&rsquo;s <code>let</code>. This macro facilitates composition of applicative computations using <code>fmap</code> and <code>fapply</code> and evaluating applicative values in parallel.</p><p>Let&rsquo;s see an example to understand how it works. This code uses fmap for executing computations inside an applicative context:</p><p>(fmap (fn [a] (inc a)) (just 1))  ;=&gt; #&lt;Just [2]&gt;</p><p>Now see how this code can be made clearer by using the alet macro:</p><p>(alet [a (just 1)]  (inc a))  ;=&gt; #&lt;Just [2]&gt;</p><p>Let&rsquo;s look at a more complex example, imagine we have dependencies between applicative values:</p><p>(join  (fapply  (fmap  (fn [a]  (fn [b]  (fmap (fn [c] (inc c))  (just (+ a b)))))  (just 1))  (just 2)))  ;=&gt; #&lt;Just [4]&gt;</p><p>This is greatly simplified using <code>alet</code>:</p><p>(alet [a (just 1)  b (just 2)  c (just (+ a b))]  (inc c))  ;=&gt; #&lt;Just [4]&gt;</p><p>The intent of the code is much clearer and evaluates <code>a</code> and <code>b</code> at the same time, then proceeds to evaluate <code>c</code> when all the values it depends on are available. This evaluation strategy is specially helpful for asynchronous applicatives.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L404">view source</a></div></div><div class="public anchor" id="var-ap"><h3><a href="#var-ap">ap</a></h3><h4 class="type">macro</h4><div class="usage"><code>(ap f &amp; args)</code></div><div class="doc"><div class="markdown"><p>Apply a pure function to applicative arguments, e.g.</p><p>(ap + (just 1) (just 2) (just 3)) ;; =&gt; #&lt;Just [6]&gt; (ap str [&ldquo;hi&rdquo; &ldquo;lo&rdquo;] [&ldquo;bye&rdquo; &ldquo;woah&rdquo; &ldquo;hey&rdquo;]) ;; =&gt; [&ldquo;hibye&rdquo; &ldquo;hiwoah&rdquo; &ldquo;hihey&rdquo;  &ldquo;lobye&rdquo; &ldquo;lowoah&rdquo; &ldquo;lohey&rdquo;]</p><p><code>ap</code> is essentially sugar for <code>(apply fapply (pure f) args)</code>, but for the common case where you have a pure, uncurried, possibly variadic function.</p><p><code>ap</code> actually desugars in <code>alet</code> form:</p><p>(macroexpand-1 `(ap + (just 1) (just2))) ;; =&gt; (alet [a1 (just 1) a2 (just 2)] (+ a1 a2))</p><p>That way, variadic functions Just Work, without needing to specify an arity separately.</p><p>If you&rsquo;re familiar with Haskell, this is closest to writing &ldquo;in Applicative style&rdquo;: you can straightforwardly convert pure function application to effectful application by with some light syntax (&lt;$&gt; and &lt;*&gt; in case of Haskell, and <code>ap</code> here).</p><p>See the original Applicative paper for more inspiration: <a href="http://staff.city.ac.uk/~ross/papers/Applicative.pdf">http://staff.city.ac.uk/~ross/papers/Applicative.pdf</a></p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L471">view source</a></div></div><div class="public anchor" id="var-ap-.3E"><h3><a href="#var-ap-.3E">ap-&gt;</a></h3><h4 class="type">macro</h4><div class="usage"><code>(ap-&gt; x &amp; forms)</code></div><div class="doc"><div class="markdown"><p>Thread like <code>-&gt;</code>, within an applicative idiom.</p><p>Compare:</p><p>(macroexpand-1 `(-&gt; a b c (d e f))) =&gt; (d (c (b a) e f)</p><p>with:</p><p>(macroexpand-1 `(ap-&gt; a b c (d e f)) =&gt; (ap d (ap c (ap b a) e f))</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L504">view source</a></div></div><div class="public anchor" id="var-ap-.3E.3E"><h3><a href="#var-ap-.3E.3E">ap-&gt;&gt;</a></h3><h4 class="type">macro</h4><div class="usage"><code>(ap-&gt;&gt; x &amp; forms)</code></div><div class="doc"><div class="markdown"><p>Thread like <code>-&gt;&gt;</code>, within an applicative idiom. See <code>cats.labs.sugar/ap-&gt;</code> for more in-depth discussion.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L527">view source</a></div></div><div class="public anchor" id="var-as-.3E.3D"><h3><a href="#var-as-.3E.3D">as-&gt;=</a></h3><h4 class="type">macro</h4><div class="usage"><code>(as-&gt;= expr name &amp; forms)</code></div><div class="doc"><div class="markdown"><p>Like <code>as-&gt;</code>, but with monadic binding instead of pure application. See <code>cats.labs.sugar/-&gt;=</code> for more in-depth discussion.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L607">view source</a></div></div><div class="public anchor" id="var-as-ap-.3E"><h3><a href="#var-as-ap-.3E">as-ap-&gt;</a></h3><h4 class="type">macro</h4><div class="usage"><code>(as-ap-&gt; expr name &amp; forms)</code></div><div class="doc"><div class="markdown"><p>Thread like <code>as-&gt;</code>, within an applicative idiom. See <code>cats.labs.sugar/ap-&gt;</code> for more in-depth discussion.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L540">view source</a></div></div><div class="public anchor" id="var-bimap"><h3><a href="#var-bimap">bimap</a></h3><div class="usage"><code>(bimap f g)</code><code>(bimap f g bv)</code></div><div class="doc"><div class="markdown"><p>Map over both arguments at the same time.</p><p>Given functions <code>f</code> and <code>g</code> and a value wrapped in a bifunctor <code>bv</code>, apply <code>f</code> to a first argument or <code>g</code> to a second argument.</p>
<pre><code>(bimap dec inc (either/right 1)
;; =&gt; #&lt;Right 2&gt;

(bimap dec inc (either/left 1)
;; =&gt; #&lt;Left 0&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L133">view source</a></div></div><div class="public anchor" id="var-bind"><h3><a href="#var-bind">bind</a></h3><div class="usage"><code>(bind mv f)</code></div><div class="doc"><div class="markdown"><p>Given a monadic value <code>mv</code> and a function <code>f</code>, apply <code>f</code> to the unwrapped value of <code>mv</code>.</p>
<pre><code>(bind (either/right 1) (fn [v]
                         (return (inc v))))
;; =&gt; #&lt;Right [2]&gt;
</code></pre><p>For convenience, you may prefer to use the <code>mlet</code> macro, which provides a beautiful, <code>let</code>-like syntax for composing operations with the <code>bind</code> function.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L81">view source</a></div></div><div class="public anchor" id="var-curry"><h3><a href="#var-curry">curry</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry f)</code><code>(curry n f)</code></div><div class="doc"><div class="markdown"><p>Given either a fixed arity function or an arity and a function, return another which is curried.</p><p>With inferred arity (function must have one fixed arity):</p>
<pre><code>(defn add2 [x y] (+ x y))
(def cadd2 (curry add2))

((cadd2 1) 3)
;; =&gt; 4

(cadd2 1 3)
;; =&gt; 4
</code></pre><p>With given arity:</p>
<pre><code>(def c+ (curry 3 +))

((c+ 1 2) 3)
;; =&gt; 6

((((c+) 1) 2) 3)
;; =&gt; 6
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L652">view source</a></div></div><div class="public anchor" id="var-curry*"><h3><a href="#var-curry*">curry*</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry* args body)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L635">view source</a></div></div><div class="public anchor" id="var-curry-lift-m"><h3><a href="#var-curry-lift-m">curry-lift-m</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry-lift-m n f)</code></div><div class="doc"><div class="markdown"><p>Composition of <code>curry</code> and <code>lift-m</code></p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L763">view source</a></div></div><div class="public anchor" id="var-extract"><h3><a href="#var-extract">extract</a></h3><div class="usage"><code>(extract v)</code></div><div class="doc"><div class="markdown"><p>Generic function to unwrap/extract the inner value of a container.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L924">view source</a></div></div><div class="public anchor" id="var-fapply"><h3><a href="#var-fapply">fapply</a></h3><div class="usage"><code>(fapply af &amp; avs)</code></div><div class="doc"><div class="markdown"><p>Given a function wrapped in a monadic context <code>af</code>, and a value wrapped in a monadic context <code>av</code>, apply the unwrapped function to the unwrapped value and return the result, wrapped in the same context as <code>av</code>.</p><p>This function is variadic, so it can be used like a Haskell-style left-associative fapply.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L186">view source</a></div></div><div class="public anchor" id="var-filter"><h3><a href="#var-filter">filter</a></h3><div class="usage"><code>(filter p mv)</code></div><div class="doc"><div class="markdown"><p>Apply a predicate to a value in a <code>MonadZero</code> instance, returning the identity element when the predicate does not hold.</p><p>Otherwise, return the instance unchanged.</p>
<pre><code>(require &#39;[cats.monad.maybe :as maybe])
(require &#39;[cats.core :as m])

(m/filter (partial &lt; 2) (maybe/just 3))
;=&gt; &lt;Just [3]&gt;

(m/filter (partial &lt; 4) (maybe/just 3))
;=&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L848">view source</a></div></div><div class="public anchor" id="var-fmap"><h3><a href="#var-fmap">fmap</a></h3><div class="usage"><code>(fmap f)</code><code>(fmap f fv)</code></div><div class="doc"><div class="markdown"><p>Apply a function <code>f</code> to the value wrapped in functor <code>fv</code>, preserving the context type.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L122">view source</a></div></div><div class="public anchor" id="var-foldl"><h3><a href="#var-foldl">foldl</a></h3><div class="usage"><code>(foldl f z xs)</code></div><div class="doc"><div class="markdown"><p>Perform a left-associative fold on the data structure.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L939">view source</a></div></div><div class="public anchor" id="var-foldm"><h3><a href="#var-foldm">foldm</a></h3><div class="usage"><code>(foldm f z xs)</code><code>(foldm ctx f z xs)</code></div><div class="doc"><div class="markdown"><p>Given an optional monadic context, a function that takes two non-monadic arguments and returns a value inside the given monadic context, an initial value, and a collection of values, perform a left-associative fold.</p>
<pre><code>(require &#39;[cats.context :as ctx]
         &#39;[cats.core :as m]
         &#39;[cats.monad.maybe :as maybe])

(defn m-div [x y]
  (if (zero? y)
    (maybe/nothing)
    (maybe/just (/ x y))))

(m/foldm m-div 1 [1 2 3])
(m/foldm maybe/context m-div 1 [1 2 3])
;; =&gt; #&lt;Just 1/6&gt;

(m/foldm maybe/context m-div 1 [1 0 3])
;; =&gt; #&lt;Nothing&gt;

(foldm m-div 1 [])
;; =&gt; Exception

(m/foldm maybe/context m-div 1 [])
(ctx/with-context maybe/context
  (foldm m-div 1 []))
;; =&gt; #&lt;Just 1&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L946">view source</a></div></div><div class="public anchor" id="var-foldr"><h3><a href="#var-foldr">foldr</a></h3><div class="usage"><code>(foldr f z xs)</code></div><div class="doc"><div class="markdown"><p>Perform a right-associative fold on the data structure.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L932">view source</a></div></div><div class="public anchor" id="var-forseq"><h3><a href="#var-forseq">forseq</a></h3><div class="usage"><code>(forseq vs mf)</code></div><div class="doc"><div class="markdown"><p>Same as <code>mapseq</code> but with the arguments flipped.</p><p>Let&rsquo;s see a little example:</p>
<pre><code>(m/forseq [2 3] maybe/just)
;; =&gt; &lt;Just [[2 3]]&gt;
</code></pre><p>Yet an other example that fails:</p>
<pre><code>(m/forseq [1 2]
          (fn [v]
            (if (odd? v)
              (maybe/just v)
              (maybe/nothing))))
;; =&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L828">view source</a></div></div><div class="public anchor" id="var-guard"><h3><a href="#var-guard">guard</a></h3><div class="usage"><code>(guard b)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L110">view source</a></div></div><div class="public anchor" id="var-join"><h3><a href="#var-join">join</a></h3><div class="usage"><code>(join mv)</code></div><div class="doc"><div class="markdown"><p>Remove one level of monadic structure. This is the same as <code>(bind mv identity)</code>.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L116">view source</a></div></div><div class="public anchor" id="var-left-map"><h3><a href="#var-left-map">left-map</a></h3><div class="usage"><code>(left-map f)</code><code>(left-map f bv)</code></div><div class="doc"><div class="markdown"><p>Map covariantly over the first argument.</p><p>Given a function <code>f</code> and a value wrapped in a bifunctor <code>bv</code>, apply <code>f</code> to the first argument, if present, otherwise leave <code>bv</code> unchanged.</p>
<pre><code>(left-map dec (either/right 1)
;; =&gt; #&lt;Right 1&gt;

(left-map dec (either/left 1)
;; =&gt; #&lt;Left 0&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L152">view source</a></div></div><div class="public anchor" id="var-lift-a"><h3><a href="#var-lift-a">lift-a</a></h3><h4 class="type">macro</h4><div class="usage"><code>(lift-a f)</code><code>(lift-a n f)</code></div><div class="doc"><div class="markdown"><p>Lift a function with a given fixed arity to an applicative context.</p><p>(def app+ (lift-a 2 +))</p><p>(app+ (maybe/just 1) (maybe/just 2)) ;; =&gt; <Just 3></p><p>(app+ (maybe/just 1) (maybe/nothing)) ;; =&gt; <Nothing></p><p>(app+ [0 2 4] [1 2]) ;; =&gt; [1 2 3 4 5 6]</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L728">view source</a></div></div><div class="public anchor" id="var-lift-m"><h3><a href="#var-lift-m">lift-m</a></h3><h4 class="type">macro</h4><div class="usage"><code>(lift-m f)</code><code>(lift-m n f)</code></div><div class="doc"><div class="markdown"><p>Lift a function with a given fixed arity to a monadic context.</p><p>(def monad+ (lift-m 2 +))</p><p>(monad+ (maybe/just 1) (maybe/just 2)) ;; =&gt; &lt;Just [3]&gt;</p><p>(monad+ (maybe/just 1) (maybe/nothing)) ;; =&gt; <Nothing></p><p>(monad+ [0 2 4] [1 2]) ;; =&gt; [1 2 3 4 5 6]</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L693">view source</a></div></div><div class="public anchor" id="var-mappend"><h3><a href="#var-mappend">mappend</a></h3><div class="usage"><code>(mappend &amp; svs)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L48">view source</a></div></div><div class="public anchor" id="var-mapseq"><h3><a href="#var-mapseq">mapseq</a></h3><div class="usage"><code>(mapseq mf coll)</code></div><div class="doc"><div class="markdown"><p>Given a function <code>mf</code> that takes a value and puts it into a monadic context, and a collection, map <code>mf</code> over the collection, calling <code>sequence</code> on the results.</p>
<pre><code>(require &#39;[cats.context :as ctx]
         &#39;[cats.monad.maybe :as maybe]
         &#39;[cats.core :as m])

(m/mapseq maybe/just [2 3])
;=&gt; &lt;Just [[2 3]]&gt;

(m/mapseq (fn [v]
            (if (odd? v)
              (maybe/just v)
              (maybe/nothing)))
          [1 2])
;; =&gt; #&lt;Nothing&gt;

(ctx/with-context maybe/context
  (mapseq #(maybe/just (* % 2)) []))
;; =&gt; #&lt;Just [()]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L802">view source</a></div></div><div class="public anchor" id="var-mempty"><h3><a href="#var-mempty">mempty</a></h3><div class="usage"><code>(mempty)</code><code>(mempty ctx)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L44">view source</a></div></div><div class="public anchor" id="var-mlet"><h3><a href="#var-mlet">mlet</a></h3><h4 class="type">macro</h4><div class="usage"><code>(mlet bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Monad composition macro that works like Clojure&rsquo;s <code>let</code>. This facilitates much easier composition of monadic computations.</p><p>Let&rsquo;s see an example to understand how it works. This code uses bind to compose a few operations:</p>
<pre><code>(bind (just 1)
      (fn [a]
        (bind (just (inc a))
                (fn [b]
                  (return (* b 2))))))
;=&gt; #&lt;Just [4]&gt;
</code></pre><p>Now see how this code can be made clearer by using the mlet macro:</p>
<pre><code>(mlet [a (just 1)
       b (just (inc a))]
  (return (* b 2)))
;=&gt; #&lt;Just [4]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L224">view source</a></div></div><div class="public anchor" id="var-mplus"><h3><a href="#var-mplus">mplus</a></h3><div class="usage"><code>(mplus &amp; mvs)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L104">view source</a></div></div><div class="public anchor" id="var-mzero"><h3><a href="#var-mzero">mzero</a></h3><div class="usage"><code>(mzero)</code><code>(mzero ctx)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L98">view source</a></div></div><div class="public anchor" id="var-pure"><h3><a href="#var-pure">pure</a></h3><div class="usage"><code>(pure v)</code><code>(pure ctx v)</code></div><div class="doc"><div class="markdown"><p>Given any value <code>v</code>, return it wrapped in the default/effect-free context.</p><p>This is a multi-arity function that with arity <code>pure/1</code> uses the dynamic scope to resolve the current context. With <code>pure/2</code>, you can force a specific context value.</p><p>Example:</p>
<pre><code>(with-context either/context
  (pure 1))
;; =&gt; #&lt;Right [1]&gt;

(pure either/context 1)
;; =&gt; #&lt;Right [1]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L54">view source</a></div></div><div class="public anchor" id="var-return"><h3><a href="#var-return">return</a></h3><div class="usage"><code>(return v)</code><code>(return ctx v)</code></div><div class="doc"><div class="markdown"><p>This is a monad version of <code>pure</code> and works identically to it.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L75">view source</a></div></div><div class="public anchor" id="var-right-map"><h3><a href="#var-right-map">right-map</a></h3><div class="usage"><code>(right-map g)</code><code>(right-map g bv)</code></div><div class="doc"><div class="markdown"><p>Map covariantly over the second argument.</p><p>Given a function <code>g</code> and a value wrapped in a bifunctor <code>bv</code>, apply <code>g</code> to the second argument, if present, otherwise leave <code>bv</code> unchanged.</p>
<pre><code>(right-map inc (either/right 1)
;; =&gt; #&lt;Right 2&gt;

(right-map inc (either/left 1)
;; =&gt; #&lt;Left 1&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L169">view source</a></div></div><div class="public anchor" id="var-sequence"><h3><a href="#var-sequence">sequence</a></h3><div class="usage"><code>(sequence mvs)</code></div><div class="doc"><div class="markdown"><p>Given a collection of monadic values, collect their values in a seq returned in the monadic context.</p>
<pre><code>(require &#39;[cats.context :as ctx]
         &#39;[cats.monad.maybe :as maybe]
         &#39;[cats.core :as m])

(m/sequence [(maybe/just 2) (maybe/just 3)])
;; =&gt; #&lt;Just [[2, 3]]&gt;

(m/sequence [(maybe/nothing) (maybe/just 3)])
;; =&gt; #&lt;Nothing&gt;

(ctx/with-context maybe/context
  (m/sequence []))
;; =&gt; #&lt;Just [()]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L772">view source</a></div></div><div class="public anchor" id="var-traverse"><h3><a href="#var-traverse">traverse</a></h3><div class="usage"><code>(traverse f tv)</code><code>(traverse ctx f tv)</code></div><div class="doc"><div class="markdown"><p>Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.</p>
<pre><code>(defn inc-if-even
  [n]
  (if (even? n)
    (maybe/just (inc n))
    (maybe/nothing)))

(ctx/with-context maybe/context
  (m/traverse inc-if-even [2 4]))
;; =&gt; #&lt;Just [3 4]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L988">view source</a></div></div><div class="public anchor" id="var-unless"><h3><a href="#var-unless">unless</a></h3><div class="usage"><code>(unless b mv)</code><code>(unless ctx b mv)</code></div><div class="doc"><div class="markdown"><p>Given an expression and a monadic value, if the expression is not logical true, return the monadic value. Otherwise, return nil in a monadic context.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L210">view source</a></div></div><div class="public anchor" id="var-when"><h3><a href="#var-when">when</a></h3><div class="usage"><code>(when b mv)</code><code>(when ctx b mv)</code></div><div class="doc"><div class="markdown"><p>Given an expression and a monadic value, if the expression is logical true, return the monadic value. Otherwise, return nil in a monadic context.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L199">view source</a></div></div></section></section></body></html>