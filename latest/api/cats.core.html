<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>cats.core documentation</title></head><body><header><section class="title"><h1><a href="index.html">Cats Api Documentation</a></h1></section><small>Version: 1.0.0</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cats</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>applicative</span></div></div></li><li class="depth-3"><a href="cats.applicative.validation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validation</span></div></a></li><li class="depth-2 branch"><a href="cats.builtin.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>builtin</span></div></a></li><li class="depth-2 branch"><a href="cats.context.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>context</span></div></a></li><li class="depth-2 branch current"><a href="cats.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="cats.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>labs</span></div></div></li><li class="depth-3 branch"><a href="cats.labs.channel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>channel</span></div></a></li><li class="depth-3 branch"><a href="cats.labs.continuation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>continuation</span></div></a></li><li class="depth-3 branch"><a href="cats.labs.manifold.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>manifold</span></div></a></li><li class="depth-3 branch"><a href="cats.labs.reader.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reader</span></div></a></li><li class="depth-3 branch"><a href="cats.labs.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-3"><a href="cats.labs.writer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>writer</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -207px;"><span class="top" style="height: 216px;"></span><span class="bottom"></span></span><span>monad</span></div></div></li><li class="depth-3 branch"><a href="cats.monad.either.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>either</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.exception.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exception</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.identity.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>identity</span></div></a></li><li class="depth-3"><a href="cats.monad.maybe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maybe</span></div></a></li><li class="depth-2"><a href="cats.protocols.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">cats.core</h2><div class="doc"><div class="markdown"><p>Category Theory abstractions for Clojure</p></div></div><div class="public anchor" id="var-.3C.24.3E"><h3><a href="#var-.3C.24.3E">&lt;$&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A Haskell-style <code>fmap</code> alias.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L626">view source</a></div></div><div class="public anchor" id="var-.3C*.3E"><h3><a href="#var-.3C*.3E">&lt;*&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A Haskell-style <code>fapply</code> alias.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L630">view source</a></div></div><div class="public anchor" id="var-.3C.3D.3C"><h3><a href="#var-.3C.3D.3C">&lt;=&lt;</a></h3><div class="usage"><code>(&lt;=&lt; mg mf x)</code></div><div class="doc"><div class="markdown"><p>Right-to-left composition of monads. Same as <code>&gt;=&gt;</code> with its first two arguments flipped.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L669">view source</a></div></div><div class="public anchor" id="var-.3C.3E"><h3><a href="#var-.3C.3E">&lt;&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L684">view source</a></div></div><div class="public anchor" id="var-.3D.3C.3C"><h3><a href="#var-.3D.3C.3C">=&lt;&lt;</a></h3><div class="usage"><code>(=&lt;&lt; f mv)</code></div><div class="doc"><div class="markdown"><p>Same as the two argument version of <code>&gt;&gt;=</code> but with the arguments flipped.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L655">view source</a></div></div><div class="public anchor" id="var-.3E.3D.3E"><h3><a href="#var-.3E.3D.3E">&gt;=&gt;</a></h3><div class="usage"><code>(&gt;=&gt; mf mg x)</code></div><div class="doc"><div class="markdown"><p>Left-to-right composition of monads.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L661">view source</a></div></div><div class="public anchor" id="var-.3E.3E"><h3><a href="#var-.3E.3E">&gt;&gt;</a></h3><div class="usage"><code>(&gt;&gt; mv mv&apos;)</code><code>(&gt;&gt; mv mv&apos; &amp; mvs)</code></div><div class="doc"><div class="markdown"><p>Perform a Haskell-style left-associative bind, ignoring the values produced by the monadic computations.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L647">view source</a></div></div><div class="public anchor" id="var-.3E.3E.3D"><h3><a href="#var-.3E.3E.3D">&gt;&gt;=</a></h3><div class="usage"><code>(&gt;&gt;= mv f)</code><code>(&gt;&gt;= mv f &amp; fs)</code></div><div class="doc"><div class="markdown"><p>Perform a Haskell-style left-associative bind.</p><p>Let&rsquo;s see it in action:</p>
<pre><code>(&gt;&gt;= (just 1) (comp just inc) (comp just inc))
;; =&gt; #&lt;Just [3]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L634">view source</a></div></div><div class="public anchor" id="var-alet"><h3><a href="#var-alet">alet</a></h3><h4 class="type">macro</h4><div class="usage"><code>(alet bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Applicative composition macro similar to Clojure&rsquo;s <code>let</code>. This macro facilitates composition of applicative computations using <code>fmap</code> and <code>fapply</code> and evaluating applicative values in parallel.</p><p>Let&rsquo;s see an example to understand how it works. This code uses fmap for executing computations inside an applicative context:</p><p>(fmap (fn [a] (inc a)) (just 1))  ;=&gt; #&lt;Just [2]&gt;</p><p>Now see how this code can be made clearer by using the alet macro:</p><p>(alet [a (just 1)]  (inc a))  ;=&gt; #&lt;Just [2]&gt;</p><p>Let&rsquo;s look at a more complex example, imagine we have dependencies between applicative values:</p><p>(join  (fapply  (fmap  (fn [a]  (fn [b]  (fmap (fn [c] (inc c))  (just (+ a b)))))  (just 1))  (just 2)))  ;=&gt; #&lt;Just [4]&gt;</p><p>This is greatly simplified using <code>alet</code>:</p><p>(alet [a (just 1)  b (just 2)  c (just (+ a b))]  (inc c))  ;=&gt; #&lt;Just [4]&gt;</p><p>The intent of the code is much clearer and evaluates <code>a</code> and <code>b</code> at the same time, then proceeds to evaluate <code>c</code> when all the values it depends on are available. This evaluation strategy is specially helpful for asynchronous applicatives.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L356">view source</a></div></div><div class="public anchor" id="var-bind"><h3><a href="#var-bind">bind</a></h3><div class="usage"><code>(bind mv f)</code></div><div class="doc"><div class="markdown"><p>Given a monadic value <code>mv</code> and a function <code>f</code>, apply <code>f</code> to the unwrapped value of <code>mv</code>.</p>
<pre><code>(bind (either/right 1) (fn [v]
                         (return (inc v))))
;; =&gt; #&lt;Right [2]&gt;
</code></pre><p>For convenience, you may prefer to use the <code>mlet</code> macro, which provides a beautiful, <code>let</code>-like syntax for composing operations with the <code>bind</code> function.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L81">view source</a></div></div><div class="public anchor" id="var-curry"><h3><a href="#var-curry">curry</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry f)</code><code>(curry n f)</code></div><div class="doc"><div class="markdown"><p>Given either a fixed arity function or an arity and a function, return another which is curried.</p><p>With inferred arity (function must have one fixed arity):</p>
<pre><code>(defn add2 [x y] (+ x y))
(def cadd2 (curry add2))

((cadd2 1) 3)
;; =&gt; 4

(cadd2 1 3)
;; =&gt; 4
</code></pre><p>With given arity:</p>
<pre><code>(def c+ (curry 3 +))

((c+ 1 2) 3)
;; =&gt; 6

((((c+) 1) 2) 3)
;; =&gt; 6
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L455">view source</a></div></div><div class="public anchor" id="var-curry*"><h3><a href="#var-curry*">curry*</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry* args body)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L438">view source</a></div></div><div class="public anchor" id="var-curry-lift-m"><h3><a href="#var-curry-lift-m">curry-lift-m</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry-lift-m n f)</code></div><div class="doc"><div class="markdown"><p>Composition of <code>curry</code> and <code>lift-m</code></p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L531">view source</a></div></div><div class="public anchor" id="var-extract"><h3><a href="#var-extract">extract</a></h3><div class="usage"><code>(extract v)</code></div><div class="doc"><div class="markdown"><p>Generic function to unwrap/extract the inner value of a container.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L678">view source</a></div></div><div class="public anchor" id="var-fapply"><h3><a href="#var-fapply">fapply</a></h3><div class="usage"><code>(fapply af &amp; avs)</code></div><div class="doc"><div class="markdown"><p>Given a function wrapped in a monadic context <code>af</code>, and a value wrapped in a monadic context <code>av</code>, apply the unwrapped function to the unwrapped value and return the result, wrapped in the same context as <code>av</code>.</p><p>This function is variadic, so it can be used like a Haskell-style left-associative fapply.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L132">view source</a></div></div><div class="public anchor" id="var-filter"><h3><a href="#var-filter">filter</a></h3><div class="usage"><code>(filter p mv)</code></div><div class="doc"><div class="markdown"><p>Apply a predicate to a value in a <code>MonadZero</code> instance, returning the identity element when the predicate does not hold.</p><p>Otherwise, return the instance unchanged.</p>
<pre><code>(require &#39;[cats.monad.maybe :as maybe])
(require &#39;[cats.core :as m])

(m/filter (partial &lt; 2) (maybe/just 3))
;=&gt; &lt;Just [3]&gt;

(m/filter (partial &lt; 4) (maybe/just 3))
;=&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L602">view source</a></div></div><div class="public anchor" id="var-fmap"><h3><a href="#var-fmap">fmap</a></h3><div class="usage"><code>(fmap f)</code><code>(fmap f fv)</code></div><div class="doc"><div class="markdown"><p>Apply a function <code>f</code> to the value wrapped in functor <code>fv</code>, preserving the context type.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L122">view source</a></div></div><div class="public anchor" id="var-foldl"><h3><a href="#var-foldl">foldl</a></h3><div class="usage"><code>(foldl f z xs)</code></div><div class="doc"><div class="markdown"><p>Perform a left-associative fold on the data structure.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L693">view source</a></div></div><div class="public anchor" id="var-foldm"><h3><a href="#var-foldm">foldm</a></h3><div class="usage"><code>(foldm f z xs)</code><code>(foldm ctx f z xs)</code></div><div class="doc"><div class="markdown"><p>Given an optional monadic context, a function that takes two non-monadic arguments and returns a value inside the given monadic context, an initial value, and a collection of values, perform a left-associative fold.</p>
<pre><code>(require &#39;[cats.context :as ctx]
         &#39;[cats.core :as m]
         &#39;[cats.monad.maybe :as maybe])

(defn m-div [x y]
  (if (zero? y)
    (maybe/nothing)
    (maybe/just (/ x y))))

(m/foldm m-div 1 [1 2 3])
(m/foldm maybe/context m-div 1 [1 2 3])
;; =&gt; #&lt;Just 1/6&gt;

(m/foldm maybe/context m-div 1 [1 0 3])
;; =&gt; #&lt;Nothing&gt;

(foldm m-div 1 [])
;; =&gt; Exception

(m/foldm maybe/context m-div 1 [])
(ctx/with-context maybe/context
  (foldm m-div 1 []))
;; =&gt; #&lt;Just 1&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L700">view source</a></div></div><div class="public anchor" id="var-foldr"><h3><a href="#var-foldr">foldr</a></h3><div class="usage"><code>(foldr f z xs)</code></div><div class="doc"><div class="markdown"><p>Perform a right-associative fold on the data structure.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L686">view source</a></div></div><div class="public anchor" id="var-forseq"><h3><a href="#var-forseq">forseq</a></h3><div class="usage"><code>(forseq vs mf)</code></div><div class="doc"><div class="markdown"><p>Same as <code>mapseq</code> but with the arguments flipped.</p><p>Let&rsquo;s see a little example:</p>
<pre><code>(m/forseq [2 3] maybe/just)
;; =&gt; &lt;Just [[2 3]]&gt;
</code></pre><p>Yet an other example that fails:</p>
<pre><code>(m/forseq [1 2]
          (fn [v]
            (if (odd? v)
              (maybe/just v)
              (maybe/nothing))))
;; =&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L582">view source</a></div></div><div class="public anchor" id="var-guard"><h3><a href="#var-guard">guard</a></h3><div class="usage"><code>(guard b)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L110">view source</a></div></div><div class="public anchor" id="var-join"><h3><a href="#var-join">join</a></h3><div class="usage"><code>(join mv)</code></div><div class="doc"><div class="markdown"><p>Remove one level of monadic structure. This is the same as <code>(bind mv identity)</code>.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L116">view source</a></div></div><div class="public anchor" id="var-lift"><h3><a href="#var-lift">lift</a></h3><div class="usage"><code>(lift mv)</code><code>(lift m mv)</code></div><div class="doc"><div class="markdown"><p>Lift a value from the inner monad of a monad transformer into a value of the monad transformer.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L165">view source</a></div></div><div class="public anchor" id="var-lift-m"><h3><a href="#var-lift-m">lift-m</a></h3><h4 class="type">macro</h4><div class="usage"><code>(lift-m f)</code><code>(lift-m n f)</code></div><div class="doc"><div class="markdown"><p>Lift a function with a given fixed arity to a monadic context.</p><p>(def monad+ (lift-m 2 +))</p><p>(monad+ (maybe/just 1) (maybe/just 2)) ;; =&gt; &lt;Just [3]&gt;</p><p>(monad+ (maybe/just 1) (maybe/nothing)) ;; =&gt; <Nothing></p><p>(monad+ [0 2 4] [1 2]) ;; =&gt; [1 2 3 4 5 6]</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L496">view source</a></div></div><div class="public anchor" id="var-mappend"><h3><a href="#var-mappend">mappend</a></h3><div class="usage"><code>(mappend &amp; svs)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L48">view source</a></div></div><div class="public anchor" id="var-mapseq"><h3><a href="#var-mapseq">mapseq</a></h3><div class="usage"><code>(mapseq mf coll)</code></div><div class="doc"><div class="markdown"><p>Given a function <code>mf</code> that takes a value and puts it into a monadic context, and a collection, map <code>mf</code> over the collection, calling <code>sequence</code> on the results.</p>
<pre><code>(require &#39;[cats.monad.maybe :as maybe])
(require &#39;[cats.core :as m])

(m/mapseq maybe/just [2 3])
;=&gt; &lt;Just [[2 3]]&gt;

(m/mapseq (fn [v]
            (if (odd? v)
              (maybe/just v)
              (maybe/nothing)))
          [1 2])
;=&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L561">view source</a></div></div><div class="public anchor" id="var-mempty"><h3><a href="#var-mempty">mempty</a></h3><div class="usage"><code>(mempty)</code><code>(mempty ctx)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L44">view source</a></div></div><div class="public anchor" id="var-mlet"><h3><a href="#var-mlet">mlet</a></h3><h4 class="type">macro</h4><div class="usage"><code>(mlet bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Monad composition macro that works like Clojure&rsquo;s <code>let</code>. This facilitates much easier composition of monadic computations.</p><p>Let&rsquo;s see an example to understand how it works. This code uses bind to compose a few operations:</p>
<pre><code>(bind (just 1)
      (fn [a]
        (bind (just (inc a))
                (fn [b]
                  (return (* b 2))))))
;=&gt; #&lt;Just [4]&gt;
</code></pre><p>Now see how this code can be made clearer by using the mlet macro:</p>
<pre><code>(mlet [a (just 1)
       b (just (inc a))]
  (return (* b 2)))
;=&gt; #&lt;Just [4]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L176">view source</a></div></div><div class="public anchor" id="var-mplus"><h3><a href="#var-mplus">mplus</a></h3><div class="usage"><code>(mplus &amp; mvs)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L104">view source</a></div></div><div class="public anchor" id="var-mzero"><h3><a href="#var-mzero">mzero</a></h3><div class="usage"><code>(mzero)</code><code>(mzero ctx)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L98">view source</a></div></div><div class="public anchor" id="var-pure"><h3><a href="#var-pure">pure</a></h3><div class="usage"><code>(pure v)</code><code>(pure ctx v)</code></div><div class="doc"><div class="markdown"><p>Given any value <code>v</code>, return it wrapped in the default/effect-free context.</p><p>This is a multi-arity function that with arity <code>pure/1</code> uses the dynamic scope to resolve the current context. With <code>pure/2</code>, you can force a specific context value.</p><p>Example:</p>
<pre><code>(with-context either/context
  (pure 1))
;; =&gt; #&lt;Right [1]&gt;

(pure either/context 1)
;; =&gt; #&lt;Right [1]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L54">view source</a></div></div><div class="public anchor" id="var-return"><h3><a href="#var-return">return</a></h3><div class="usage"><code>(return v)</code><code>(return ctx v)</code></div><div class="doc"><div class="markdown"><p>This is a monad version of <code>pure</code> and works identically to it.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L75">view source</a></div></div><div class="public anchor" id="var-sequence"><h3><a href="#var-sequence">sequence</a></h3><div class="usage"><code>(sequence mvs)</code></div><div class="doc"><div class="markdown"><p>Given a non-empty collection of monadic values, collect their values in a vector returned in the monadic context.</p>
<pre><code>(sequence [(maybe/just 2) (maybe/just 3)])
;; =&gt; &lt;Just [[2, 3]]&gt;

(sequence [(maybe/nothing) (maybe/just 3)])
;; =&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L540">view source</a></div></div><div class="public anchor" id="var-traverse"><h3><a href="#var-traverse">traverse</a></h3><div class="usage"><code>(traverse f tv)</code><code>(traverse ctx f tv)</code></div><div class="doc"><div class="markdown"><p>Map each element of a structure to an action, evaluate these actions from left to right, and collect the results.</p>
<pre><code>(defn inc-if-even
  [n]
  (if (even? n)
    (maybe/just (inc n))
    (maybe/nothing)))

(ctx/with-context maybe/context
  (m/traverse inc-if-even [2 4]))
;; =&gt; #&lt;Just [3 4]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L742">view source</a></div></div><div class="public anchor" id="var-unless"><h3><a href="#var-unless">unless</a></h3><div class="usage"><code>(unless b mv)</code><code>(unless ctx b mv)</code></div><div class="doc"><div class="markdown"><p>Given an expression and a monadic value, if the expression is not logical true, return the monadic value. Otherwise, return nil in a monadic context.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L156">view source</a></div></div><div class="public anchor" id="var-when"><h3><a href="#var-when">when</a></h3><div class="usage"><code>(when b mv)</code><code>(when ctx b mv)</code></div><div class="doc"><div class="markdown"><p>Given an expression and a monadic value, if the expression is logical true, return the monadic value. Otherwise, return nil in a monadic context.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L145">view source</a></div></div></section></section></body></html>