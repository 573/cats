<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>cats.core documentation</title></head><body><header><section class="title"><h1><a href="index.html">Cats Api Documentation</a></h1></section><small>Version: 0.6.1</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cats</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>applicative</span></div></div></li><li class="depth-3"><a href="cats.applicative.validation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>validation</span></div></a></li><li class="depth-2 branch"><a href="cats.builtin.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>builtin</span></div></a></li><li class="depth-2 branch"><a href="cats.context.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>context</span></div></a></li><li class="depth-2 branch current"><a href="cats.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="cats.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2"><a href="cats.monad.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>monad</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.either.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>either</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.exception.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exception</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.identity.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>identity</span></div></a></li><li class="depth-3"><a href="cats.monad.maybe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maybe</span></div></a></li><li class="depth-2"><a href="cats.protocols.html"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">cats.core</h2><div class="doc"><div class="markdown"><p>Category Theory abstractions for Clojure</p></div></div><div class="public anchor" id="var-.3C.24.3E"><h3><a href="#var-.3C.24.3E">&lt;$&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A haskell-style fmap alias.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L427">view source</a></div></div><div class="public anchor" id="var-.3C*.3E"><h3><a href="#var-.3C*.3E">&lt;*&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A haskell-style fapply alias.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L431">view source</a></div></div><div class="public anchor" id="var-.3C.3D.3C"><h3><a href="#var-.3C.3D.3C">&lt;=&lt;</a></h3><div class="usage"><code>(&lt;=&lt; mg mf x)</code></div><div class="doc"><div class="markdown"><p>Right-to-left composition of monads. Same as <code>&gt;=&gt;</code> with its first two arguments flipped.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L471">view source</a></div></div><div class="public anchor" id="var-.3C.3E"><h3><a href="#var-.3C.3E">&lt;&gt;</a></h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L486">view source</a></div></div><div class="public anchor" id="var-.3D.3C.3C"><h3><a href="#var-.3D.3C.3C">=&lt;&lt;</a></h3><div class="usage"><code>(=&lt;&lt; f mv)</code></div><div class="doc"><div class="markdown"><p>Same as the two argument version of <code>&gt;&gt;=</code> but with the arguments interchanged.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L457">view source</a></div></div><div class="public anchor" id="var-.3E.3D.3E"><h3><a href="#var-.3E.3D.3E">&gt;=&gt;</a></h3><div class="usage"><code>(&gt;=&gt; mf mg x)</code></div><div class="doc"><div class="markdown"><p>Left-to-right composition of monads.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L463">view source</a></div></div><div class="public anchor" id="var-.3E.3E"><h3><a href="#var-.3E.3E">&gt;&gt;</a></h3><div class="usage"><code>(&gt;&gt; mv mv&apos;)</code><code>(&gt;&gt; mv mv&apos; &amp; mvs)</code></div><div class="doc"><div class="markdown"><p>Performs a Haskell-style left-associative bind, ignoring the values produced by the monad computations.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L449">view source</a></div></div><div class="public anchor" id="var-.3E.3E.3D"><h3><a href="#var-.3E.3E.3D">&gt;&gt;=</a></h3><div class="usage"><code>(&gt;&gt;= mv f)</code><code>(&gt;&gt;= mv f &amp; fs)</code></div><div class="doc"><div class="markdown"><p>Performs a Haskell-style left-associative bind.</p><p>Let see it in action:</p>
<pre><code>(&gt;&gt;= (just 1) (comp just inc) (comp just inc))
;; =&gt; #&lt;Just [3]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L435">view source</a></div></div><div class="public anchor" id="var-bind"><h3><a href="#var-bind">bind</a></h3><div class="usage"><code>(bind mv f)</code></div><div class="doc"><div class="markdown"><p>Given a value inside monadic context <code>mv</code> and any function, applies a function to value of mv.</p>
<pre><code>(bind (either/right 1) (fn [v]
                         (return (inc v))))
;; =&gt; #&lt;Right [2]&gt;
</code></pre><p>For convenience, you may prefer use a <code>mlet</code> macro that add a beautiful, let like syntax for compose operations with <code>bind</code> function.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L95">view source</a></div></div><div class="public anchor" id="var-curry"><h3><a href="#var-curry">curry</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry f)</code><code>(curry n f)</code></div><div class="doc"><div class="markdown"><p>Given either a fixed arity function or an arity and a function yields another which is curried.</p><p>With inferred arity (function must have one fixed arity)</p>
<pre><code>(defn add2 [x y] (+ x y))
(def cadd2 (curry add2))

((cadd2 1) 3)
;; =&gt; 4

(cadd2 1 3)
;; =&gt; 4
</code></pre><p>With fixed arity:</p>
<pre><code>(def c+ (curry 3 +))

((c+ 1 2) 3)
;; =&gt; 6

((((c+) 1) 2) 3)
;; =&gt; 6
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L253">view source</a></div></div><div class="public anchor" id="var-curry*"><h3><a href="#var-curry*">curry*</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry* args body)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L236">view source</a></div></div><div class="public anchor" id="var-curry-lift-m"><h3><a href="#var-curry-lift-m">curry-lift-m</a></h3><h4 class="type">macro</h4><div class="usage"><code>(curry-lift-m n f)</code></div><div class="doc"><div class="markdown"><p>Is a composition of curry and lift-m macros.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L331">view source</a></div></div><div class="public anchor" id="var-extract"><h3><a href="#var-extract">extract</a></h3><div class="usage"><code>(extract v)</code></div><div class="doc"><div class="markdown"><p>Generic function for unwrap/extract the inner value of a container.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L480">view source</a></div></div><div class="public anchor" id="var-fapply"><h3><a href="#var-fapply">fapply</a></h3><div class="usage"><code>(fapply af &amp; avs)</code></div><div class="doc"><div class="markdown"><p>Given function inside af&rsquo;s context and value inside av&rsquo;s context, applies the function to value and return a result wrapped in context of same type of av context.</p><p>This function is variadic, so it can be used like a haskell style left-associative fapply.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L145">view source</a></div></div><div class="public anchor" id="var-filter"><h3><a href="#var-filter">filter</a></h3><div class="usage"><code>(filter p mv)</code></div><div class="doc"><div class="markdown"><p>Applies a predicate to a value in a <code>MonadZero</code> instance, returning the identity element when the predicate yields false.</p><p>Otherwise, returns the instance unchanged.</p>
<pre><code>(require &#39;[cats.monad.moaybe :as maybe])
(require &#39;[cats.core :as m])

(m/filter (partial &lt; 2) (maybe/just 3))
;=&gt; &lt;Just [3]&gt;

(m/filter (partial &lt; 4) (maybe/just 3))
;=&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L402">view source</a></div></div><div class="public anchor" id="var-fmap"><h3><a href="#var-fmap">fmap</a></h3><div class="usage"><code>(fmap f)</code><code>(fmap f fv)</code></div><div class="doc"><div class="markdown"><p>Apply a function f to the value inside functor&rsquo;s fv preserving the context type.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L135">view source</a></div></div><div class="public anchor" id="var-foldl"><h3><a href="#var-foldl">foldl</a></h3><div class="usage"><code>(foldl f z xs)</code></div><div class="doc"><div class="markdown"><p>Perform a right-associative fold on the data structure.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L495">view source</a></div></div><div class="public anchor" id="var-foldr"><h3><a href="#var-foldr">foldr</a></h3><div class="usage"><code>(foldr f z xs)</code></div><div class="doc"><div class="markdown"><p>Perform a right-associative fold on the data structure.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L488">view source</a></div></div><div class="public anchor" id="var-forseq"><h3><a href="#var-forseq">forseq</a></h3><div class="usage"><code>(forseq vs mf)</code></div><div class="doc"><div class="markdown"><p>Same as mapseq but with the arguments in reverse order.</p><p>Let se a little example:</p>
<pre><code>(m/forseq [2 3] maybe/just)
;; =&gt; &lt;Just [[2 3]]&gt;
</code></pre><p>Yet an other example that fails:</p>
<pre><code>(m/forseq [1 2]
          (fn [v]
            (if (odd? v)
              (maybe/just v)
              (maybe/nothing))))
;; =&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L382">view source</a></div></div><div class="public anchor" id="var-get-current-context"><h3><a href="#var-get-current-context">get-current-context</a></h3><h4 class="deprecated">deprecated</h4><div class="usage"><code>(get-current-context)</code><code>(get-current-context default)</code></div><div class="doc"><div class="markdown"><p>Alias to cats.context/get-current for backward compatibility.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L50">view source</a></div></div><div class="public anchor" id="var-guard"><h3><a href="#var-guard">guard</a></h3><div class="usage"><code>(guard b)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L123">view source</a></div></div><div class="public anchor" id="var-join"><h3><a href="#var-join">join</a></h3><div class="usage"><code>(join mv)</code></div><div class="doc"><div class="markdown"><p>Remove one level of monadic structure. This is same as that <code>(bind mv identity)</code></p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L129">view source</a></div></div><div class="public anchor" id="var-lift"><h3><a href="#var-lift">lift</a></h3><div class="usage"><code>(lift mv)</code><code>(lift m mv)</code></div><div class="doc"><div class="markdown"><p>Lift a value from the inner monad of a monad transformer into a value of the monad transformer.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L172">view source</a></div></div><div class="public anchor" id="var-lift-m"><h3><a href="#var-lift-m">lift-m</a></h3><h4 class="type">macro</h4><div class="usage"><code>(lift-m f)</code><code>(lift-m n f)</code></div><div class="doc"><div class="markdown"><p>Lifts a function with the given fixed number of arguments to a monadic context.</p>
<pre><code>(def monad+ (lift-m 2 +))

(monad+ (maybe/just 1) (maybe/just 2))
;; =&gt; &lt;Just [3]&gt;

(monad+ (maybe/just 1) (maybe/nothing))
;; =&gt; &lt;Nothing&gt;

(monad+ [0 2 4] [1 2])
;; =&gt; [1 2 3 4 5 6]
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L295">view source</a></div></div><div class="public anchor" id="var-mappend"><h3><a href="#var-mappend">mappend</a></h3><div class="usage"><code>(mappend &amp; svs)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L65">view source</a></div></div><div class="public anchor" id="var-mapseq"><h3><a href="#var-mapseq">mapseq</a></h3><div class="usage"><code>(mapseq mf coll)</code></div><div class="doc"><div class="markdown"><p>Given a function that takes a value and puts it into a monadic context, map it into the given collection calling sequence on the results.</p>
<pre><code>(require &#39;[cats.monad.maybe :as maybe])
(require &#39;[cats.core :as m])

(m/mapseq maybe/just [2 3])
;=&gt; &lt;Just [[2 3]]&gt;

(m/mapseq (fn [v]
             (if (odd? v)
               (maybe/just v)
               (maybe/nothing)))
            [1 2])
;=&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L361">view source</a></div></div><div class="public anchor" id="var-mempty"><h3><a href="#var-mempty">mempty</a></h3><div class="usage"><code>(mempty)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L60">view source</a></div></div><div class="public anchor" id="var-mlet"><h3><a href="#var-mlet">mlet</a></h3><h4 class="type">macro</h4><div class="usage"><code>(mlet bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Monad composition macro that works like clojure let. This allows much easy composition of monadic computations.</p><p>Let see one example for understand how it works, this is a code using bind for compose few number of operations:</p>
<pre><code>(bind (just 1)
      (fn [a]
        (bind (just (inc a))
                (fn [b]
                  (return (* b 2))))))
;=&gt; #&lt;Just [4]&gt;
</code></pre><p>Now see how this code can be more clear if you are using mlet macro for do it:</p>
<pre><code>(mlet [a (just 1)
       b (just (inc a))]
  (return (* b 2)))
;=&gt; #&lt;Just [4]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L183">view source</a></div></div><div class="public anchor" id="var-mplus"><h3><a href="#var-mplus">mplus</a></h3><div class="usage"><code>(mplus &amp; mvs)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L117">view source</a></div></div><div class="public anchor" id="var-mzero"><h3><a href="#var-mzero">mzero</a></h3><div class="usage"><code>(mzero)</code><code>(mzero ctx)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L111">view source</a></div></div><div class="public anchor" id="var-pure"><h3><a href="#var-pure">pure</a></h3><div class="usage"><code>(pure v)</code><code>(pure ctx v)</code></div><div class="doc"><div class="markdown"><p>Given any value v, return it wrapped in default/effect free context.</p><p>This is multiarity function that with arity pure/1 it uses the dynamic scope to resolve the current context. With <code>pure/2</code>, you can force a specific context value.</p><p>Example:</p>
<pre><code>(with-context either/either-monad
  (pure 1)
;; =&gt; #&lt;Right [1]&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L71">view source</a></div></div><div class="public anchor" id="var-return"><h3><a href="#var-return">return</a></h3><div class="usage"><code>(return v)</code><code>(return ctx v)</code></div><div class="doc"><div class="markdown"><p>This is a monad version of pure and it works identically to it.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L89">view source</a></div></div><div class="public anchor" id="var-sequence"><h3><a href="#var-sequence">sequence</a></h3><div class="usage"><code>(sequence mvs)</code></div><div class="doc"><div class="markdown"><p>Given a non-empty collection of monadic values, collect their values in a vector returned in the monadic context.</p>
<pre><code>(sequence [(maybe/just 2) (maybe/just 3)])
;; =&gt; &lt;Just [[2, 3]]&gt;

(sequence [(maybe/nothing) (maybe/just 3)])
;; =&gt; &lt;Nothing&gt;
</code></pre></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L340">view source</a></div></div><div class="public anchor" id="var-unless"><h3><a href="#var-unless">unless</a></h3><div class="usage"><code>(unless b mv)</code></div><div class="doc"><div class="markdown"><p>If the expression is false, returns the monadic value. Otherwise, yields nil in a monadic context.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L165">view source</a></div></div><div class="public anchor" id="var-when"><h3><a href="#var-when">when</a></h3><div class="usage"><code>(when b mv)</code><code>(when ctx b mv)</code></div><div class="doc"><div class="markdown"><p>If the expression is true, returns the monadic value. Otherwise, yields nil in a monadic context.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L157">view source</a></div></div><div class="public anchor" id="var-with-monad"><h3><a href="#var-with-monad">with-monad</a></h3><h4 class="type">macro</h4><h4 class="deprecated">deprecated</h4><div class="usage"><code>(with-monad ctx &amp; body)</code></div><div class="doc"><div class="markdown"><p>Alias to <code>with-context</code> for backward compatibility.</p></div></div><div class="src-link"><a href="http://github.com/funcool/cats/blob/master/src/cats/core.cljc#L43">view source</a></div></div></section></section></body></html>