<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="Andrey Antukh &amp; Alejandro Gómez">
<title>Cats Documentation</title>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://www.niwi.nz/_assets/asciidoctor-styles/simple-red-titles/stylesheet.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Cats Documentation</h1>
<div class="details">
<span id="author" class="author">Andrey Antukh &amp; Alejandro Gómez</span><br>
<span id="revdate">0.6.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_rationale">2. Rationale</a></li>
<li><a href="#_project_maturity">3. Project Maturity</a></li>
<li><a href="#_install">4. Install</a>
<ul class="sectlevel2">
<li><a href="#_leiningen">4.1. Leiningen</a></li>
</ul>
</li>
<li><a href="#_user_guide">5. User Guide</a>
<ul class="sectlevel2">
<li><a href="#_semigroup">5.1. Semigroup</a></li>
<li><a href="#_monoid">5.2. Monoid</a></li>
<li><a href="#_functor">5.3. Functor</a></li>
<li><a href="#_applicative">5.4. Applicative</a></li>
<li><a href="#_foldable">5.5. Foldable</a></li>
<li><a href="#_monad">5.6. Monad</a></li>
<li><a href="#_monadzero">5.7. MonadZero</a></li>
<li><a href="#_monadplus">5.8. MonadPlus</a></li>
<li><a href="#_monad_transformers">5.9. Monad Transformers</a></li>
</ul>
</li>
<li><a href="#_types">6. Types</a>
<ul class="sectlevel2">
<li><a href="#_maybe">6.1. Maybe</a></li>
<li><a href="#_either">6.2. Either</a></li>
<li><a href="#_exception">6.3. Exception</a></li>
<li><a href="#_validation">6.4. Validation</a></li>
<li><a href="#_built_in_types">6.5. Built in types</a></li>
<li><a href="#_complementary_libraries">6.6. Complementary libraries</a></li>
</ul>
</li>
<li><a href="#_higher_order_functions">7. Higher-order functions</a>
<ul class="sectlevel2">
<li><a href="#_curry">7.1. curry</a></li>
<li><a href="#_lift_m">7.2. lift-m</a></li>
</ul>
</li>
<li><a href="#_faq">8. FAQ</a>
<ul class="sectlevel2">
<li><a href="#_what_clojure_types_implement_some_of_the_category_theory_abstractions">8.1. What Clojure types implement some of the Category Theory abstractions?</a></li>
<li><a href="#_where_are_the_state_reader_writer_and_continuation_monads">8.2. Where are the State, Reader, Writer and Continuation monads?</a></li>
</ul>
</li>
<li><a href="#_developers_guide">9. Developers Guide</a>
<ul class="sectlevel2">
<li><a href="#_philosophy">9.1. Philosophy</a></li>
<li><a href="#_contributing">9.2. Contributing</a></li>
<li><a href="#_source_code">9.3. Source Code</a></li>
<li><a href="#_run_tests">9.4. Run tests</a></li>
<li><a href="#_license">9.5. License</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><span class="image"><img src="logo.png" alt="cats logo"></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Category Theory and algebraic abstractions for Clojure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rationale">2. Rationale</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The main motivations for writing this library are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The existing libraries do not have support for ClojureScript.</p>
</li>
<li>
<p>We do not intend to write a little Haskell inside Clojure. We have adopted a
practical and Clojure like approach, always with correctness in mind.</p>
</li>
<li>
<p>We do not like viral/copyleft like licenses and in contrast to other libraries
cats is licensed under the BSD (2 clauses) license.</p>
</li>
<li>
<p>We do not intend to only implement monads. Other category theory and algebraic abstractions
are also first class in cats.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Alternatives:</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>algo.monads</strong>: This is the official Clojure library for monads. Its approach for modeling
monads is slightly limited, only supports the monad abstraction and does not have support for
ClojureScript.</p>
</li>
<li>
<p><strong>fluokitten</strong>: Slightly unmaintaned by the original author. It is focused on being very practical
without taking care of correctness (for example, it extends Clojure types with monadic abstractions
that do not make sense). It has no support for ClojureScript either.</p>
</li>
<li>
<p><strong>monads</strong>: Is the most advanced monads library, supports also functors, applicatives and other
related abstractions. It lacks a good and readable documentation, focus on correctness, has
Haskell like sugar syntax (instead of Clojure like syntax) and does not have support for ClojureScript.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All listed alternatives are licensed with EPL or similar licenses.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_project_maturity">3. Project Maturity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since <em>cats</em> is a young project, there can be some <a href="api/index.html#id">API</a> breakage.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_install">4. Install</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section covers installing <em>cats</em>.</p>
</div>
<div class="sect2">
<h3 id="_leiningen">4.1. Leiningen</h3>
<div class="paragraph">
<p>The simplest way to use <em>cats</em> in a Clojure project is by including
it as a dependency in your <strong><em>project.clj</em></strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">[</span><span class="tok-nv">funcool/cats</span> <span class="tok-s">&quot;0.6.0&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_user_guide">5. User Guide</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section introduces almost all the category theory and algebraic abstractions that the <em>cats</em> library
supports.</p>
</div>
<div class="paragraph">
<p>We will use <em>Maybe</em> for the example snippets, because it has support for all
the abstractions and is very easy to understand. You can read more about it in the next
section of this documentation.</p>
</div>
<div class="sect2">
<h3 id="_semigroup">5.1. Semigroup</h3>
<div class="paragraph">
<p>A semigroup is an algebraic structure with an associative binary operation (<code>mappend</code>). Most of the builtin collections
form a semigroup because their associative binary operation is analogous to Clojure&#8217;s <code>into</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5 6]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Given that the values it contains form a Semigroup, we can <code>mappend</code> multiple <em>Maybe</em> values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; #&lt;Just [1 2 3 4 5 6]&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_monoid">5.2. Monoid</h3>
<div class="paragraph">
<p>A Monoid is a Semigroup with an identity element (<code>mempty</code>). For the collection types the <code>mempty</code>
function is analogous to Clojure&#8217;s <code>empty</code>.</p>
</div>
<div class="paragraph">
<p>Given that the values it contains form a Semigroup, we can <code>mappend</code> multiple
<em>Maybe</em>, with Nothing being the identity element.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">[</span><span class="tok-mi">4</span> <span class="tok-mi">5</span> <span class="tok-mi">6</span><span class="tok-p">])</span>
           <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just [1 2 3 4 5 6]&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_functor">5.3. Functor</h3>
<div class="paragraph">
<p>Let&#8217;s dive into the functor. The Functor represents some sort of "computational context", and the
abstraction consists of one unique function: <strong>fmap</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Signature of <strong>fmap</strong> function</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">fmap</span> <span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-nv">fv</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The higher-order function <strong>fmap</strong> takes a plain function as the first parameter and
a value wrapped in a functor context as the second parameter. It extracts the
inner value, applies the function to it and returns the result wrapped in same type
as the second parameter.</p>
</div>
<div class="paragraph">
<p>But what is the <strong>functor context</strong>? It sounds more complex than it is. A Functor
wrapper is any type that acts as "Box" and implements the <code>Context</code> and <code>Functor</code> protocols.</p>
</div>
<div class="listingblock">
<div class="title">One good example of a functor is the <strong>Maybe</strong> type:</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>just</code> function is a constructor of the Just type that is part of the Maybe monad.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see one example of using <strong>fmap</strong> over a <strong>just</strong> instance:</p>
</div>
<div class="listingblock">
<div class="title">Example using fmap over <strong>just</strong> instance.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <strong>Maybe</strong> type also has another constructor: <code>nothing</code>. It represents the absence of a value.
It is a safe substitute for <code>nil</code> and may represent failure.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see what happens if we perform the same operation as the previous example over a <strong>nothing</strong>
instance:</p>
</div>
<div class="listingblock">
<div class="title">Example using fmap over <strong>nothing</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Oh, awesome, instead of raising a <code>NullPointerException</code>, it just returns <strong>nothing</strong>. Another
advantage of using the functor abstraction, is that it always returns a result
of the same type as its second argument.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example of applying fmap over a Clojure vector:</p>
</div>
<div class="listingblock">
<div class="title">Example using fmav over <strong>vector</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 3 4]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main difference compared to the previous example with Clojure&#8217;s map function, is that
map returns lazy seqs no matter what collection we pass to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">type</span> <span class="tok-p">(</span><span class="tok-nb">map inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">]))</span>
<span class="tok-c1">;; =&gt; clojure.lang.LazySeq (cljs.core/LazySeq in ClojureScript)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>But why can we pass vectors to the <code>fmap</code> function? Because some Clojure container types like vectors,
lists and sets, also implement the functor abstraction. See the section on built-in types for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="_applicative">5.4. Applicative</h3>
<div class="paragraph">
<p>Let&#8217;s continue with applicative functors. The Applicative Functor represents
some sort of "computational context" like a plain Functor, but with the ability to
execute a function wrapped in the same context.</p>
</div>
<div class="paragraph">
<p>The Applicative Functor abstraction consists of two functions: <strong>fapply</strong> and
<strong>pure</strong>.</p>
</div>
<div class="listingblock">
<div class="title">Signature of <strong>fapply</strong> function</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">[</span><span class="tok-nv">af</span> <span class="tok-nv">av</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
the <strong>pure</strong> function will be explained later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The use case for Applicative Functors is roughly the same as for plain Functors: safe
evaluation of some computation in a context.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see an example to better understand the differences between functor and
applicative functor:</p>
</div>
<div class="paragraph">
<p>Imagine you have some factory function that, depending on the language, returns a
greeter function, and you only support a few languages.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">make-greeter</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">String</span> <span class="tok-nv">lang</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">condp</span> <span class="tok-nb">= </span><span class="tok-nv">lang</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hola &quot;</span> <span class="tok-nv">name</span><span class="tok-p">))</span>
    <span class="tok-s">&quot;en&quot;</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hello &quot;</span> <span class="tok-nv">name</span><span class="tok-p">))</span>
    <span class="tok-nv">nil</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, before using the resulting greeter you should always defensively check if
the returned greeter is a valid function or a nil value.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s convert this factory to use the Maybe type:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">make-greeter</span>
  <span class="tok-p">[</span><span class="tok-o">^</span><span class="tok-nv">String</span> <span class="tok-nv">lang</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">condp</span> <span class="tok-nb">= </span><span class="tok-nv">lang</span>
    <span class="tok-s">&quot;es&quot;</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hola &quot;</span> <span class="tok-nv">name</span><span class="tok-p">)))</span>
    <span class="tok-s">&quot;en&quot;</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">name</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">str </span><span class="tok-s">&quot;Hello &quot;</span> <span class="tok-nv">name</span><span class="tok-p">)))</span>
    <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, this version of the factory differs only slightly from the
original implementation. And this tiny change gives you a new superpower: you
can apply the returned greeter to any value without a defensive nil check:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">(</span><span class="tok-nf">make-greeter</span> <span class="tok-s">&quot;es&quot;</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-s">&quot;Alex&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just &quot;Hola Alex&quot;&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">(</span><span class="tok-nf">make-greeter</span> <span class="tok-s">&quot;en&quot;</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-s">&quot;Alex&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just &quot;Hello Alex&quot;&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">fapply</span> <span class="tok-p">(</span><span class="tok-nf">make-greeter</span> <span class="tok-s">&quot;it&quot;</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-s">&quot;Alex&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Moreover, the applicative functor comes with the <strong>pure</strong> function, which allows
you to put some value in side-effect-free context of the current type.</p>
</div>
<div class="paragraph">
<p>Examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">pure</span> <span class="tok-nv">maybe/maybe-monad</span> <span class="tok-mi">5</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Just 5&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not understand the purpose of the <strong>pure</strong> function, the next section
should clarify its purpose.</p>
</div>
</div>
<div class="sect2">
<h3 id="_foldable">5.5. Foldable</h3>
<div class="paragraph">
<p>The <strong>Foldable</strong> is a generic abstraction for data structures that can be folded. It consists
mainly on two functions: <code>foldl</code> and <code>foldr</code>. <code>foldl</code> is also known as <code>reduce</code> or <code>inject</code>
in other mainstream programming languages.</p>
</div>
<div class="paragraph">
<p>Both function have an identical signature and differ in how they traverse the data structure.
Let&#8217;s look at a little example using <code>foldl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">foldl</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>You can observe that <code>foldl</code> is identical to the clojure <code>reduce</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">reduce </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">acc</span> <span class="tok-nv">v</span><span class="tok-p">))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the same operation can be done using <code>foldr</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">foldr</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span> <span class="tok-nv">wc</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">v</span> <span class="tok-nv">wc</span><span class="tok-p">))</span> <span class="tok-mi">0</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; 15</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The main difference between <code>foldl</code> and <code>reduce</code> is that <code>foldl</code> has a fixed arity so all
parameters are mandatory and <code>foldl</code> is a generic abstraction that can work with other
types apart from collections.</p>
</div>
<div class="paragraph">
<p>As we said previously, the <code>foldl</code> and <code>foldr</code> differ mainly on how they traverse the
data structure. Then, for understanding better how they work internally, let&#8217;s see a
graphical representation of the <code>foldl</code> execution model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">((((acc⊕1)⊕2)⊕3)⊕4)⊕5</code></pre>
</div>
</div>
<div class="paragraph">
<p>In contrast to the <code>foldr</code> internal execution model:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">1⊕(2⊕(3⊕(4⊕(5⊕(wc)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In languages with strict argument evaluation, <code>foldr</code> does not have many
applications because when the data structure to fold grows it tends to consume all the
stack (causing the well known stack overflow). In case of Clojure, the unique obvious
case of using foldr is for small datastructures or lazy sequences.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">m/foldr</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">%1</span><span class="tok-p">)</span> <span class="tok-nv">%2</span><span class="tok-p">)</span> <span class="tok-o">&#39;</span><span class="tok-p">()</span> <span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100000</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; StackOverflowError</span>

<span class="tok-c1">;; The same operation but using lazyseqs works as expected</span>
<span class="tok-p">(</span><span class="tok-nf">m/foldr</span> <span class="tok-o">#</span><span class="tok-p">(</span><span class="tok-nb">cons </span><span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">%1</span><span class="tok-p">)</span> <span class="tok-nv">%2</span><span class="tok-p">)</span> <span class="tok-o">&#39;</span><span class="tok-p">()</span> <span class="tok-p">(</span><span class="tok-nb">map identity </span><span class="tok-p">(</span><span class="tok-nb">range </span><span class="tok-mi">100000</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; (1 2 3 4 ...)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_monad">5.6. Monad</h3>
<div class="paragraph">
<p>Monads are the most discussed programming concept to come from category theory. Like functors and
applicatives, monads deal with data in contexts.</p>
</div>
<div class="paragraph">
<p>Additionally, monads can also transform contexts by unwrapping data, applying functions to it and
putting new values in a completely different context.</p>
</div>
<div class="paragraph">
<p>The monad abstraction consists of two functions: <strong>bind</strong> and <strong>return</strong></p>
</div>
<div class="listingblock">
<div class="title">Bind function signature.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">bind</span> <span class="tok-p">[</span><span class="tok-nv">mv</span> <span class="tok-nv">f</span><span class="tok-p">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, bind works much like a Functor but with inverted arguments. The main difference is
that in a monad, the function is responsible for wrapping a returned value in a context.</p>
</div>
<div class="listingblock">
<div class="title">Example usage of the bind higher-order function.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">v</span><span class="tok-p">))))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>One of the key features of the bind function is that any computation executed within the context of
bind (monad) knows the context type implicitly. With this, if you apply some computation over some
monadic value and you want to return the result in the same container context but don&#8217;t know
what that container is, you can use <code>return</code> or <code>pure</code> functions:</p>
</div>
<div class="listingblock">
<div class="title">Usage of return function in bind context.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">v</span><span class="tok-p">))))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 2&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>return</code> or <code>pure</code> functions, when called with one argument, try to use the dynamic scope context
value that&#8217;s set internally by the <code>bind</code> function. Therefore, you can&#8217;t use them with one argument outside of a <code>bind</code> context.</p>
</div>
<div class="paragraph">
<p>We now can compose any number of computations using monad <strong>bind</strong>
functions. But observe what happens when the number of computations increases:</p>
</div>
<div class="listingblock">
<div class="title">Composability example of bind function.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))</span>
                  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">b</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">b</span> <span class="tok-mi">2</span><span class="tok-p">))))))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>This can quickly lead to callback hell. To solve this, <em>cats</em> comes with a powerful
macro: <strong>mlet</strong></p>
</div>
<div class="listingblock">
<div class="title">Previous example but using <strong>mlet</strong> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">b</span> <span class="tok-mi">2</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
If you are coming from Haskell, mlet represents the <strong>do-syntax</strong>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to use regular (non-monadic) let bindings inside an <code>mlet</code> block, you can do so using
<code>:let</code> and a binding vector inside the mlet bindings:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-nv">b</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">a</span><span class="tok-p">))</span>
         <span class="tok-ss">:let</span> <span class="tok-p">[</span><span class="tok-nv">z</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span><span class="tok-p">)]]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">z</span> <span class="tok-mi">2</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_monadzero">5.7. MonadZero</h3>
<div class="paragraph">
<p>Some monads also have the notion of an identity element analogous to that of Monoid. When calling <code>bind</code> on a identity element
for a monad, the same value is returned. This means that whenever we encounter the identity element in a monadic composition it will
short-circuit.</p>
</div>
<div class="paragraph">
<p>For the already familiar Maybe type the identity element is Nothing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mzero</span> <span class="tok-nv">maybe/maybe-monad</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Having an identity element we can make a monadic composition short-circuit using a predicate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/mzero</span><span class="tok-p">))</span>
                  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">))))))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the above example the predicate <code>(= a 2)</code> returns either a monadic value <code>(m/return nil)</code> or the identity value
for the maybe monad. This can be captured in a function, which is available in <code>cats.core</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">guard</span>
  <span class="tok-p">[</span><span class="tok-nv">b</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-k">if </span><span class="tok-nv">b</span>
    <span class="tok-p">(</span><span class="tok-nf">return</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
    <span class="tok-p">(</span><span class="tok-nf">mzero</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example could be rewritten as:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">a</span><span class="tok-p">]</span>
          <span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-p">(</span><span class="tok-nf">m/guard</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
                  <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">_</span><span class="tok-p">]</span>
                    <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">))))))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>mlet</code> has support for using guards using a <code>:when</code> clause, analogous to the one used in <code>for</code>. We could rewrite the above example
using <code>bind</code> with <code>mlet</code> and <code>:when</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
         <span class="tok-ss">:when</span> <span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)]</span>
   <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">* </span><span class="tok-nv">a</span> <span class="tok-mi">2</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Any monadic type that implements <code>MonadZero</code> can be combined with guards inside <code>mlet</code> bindings.</p>
</div>
</div>
<div class="sect2">
<h3 id="_monadplus">5.8. MonadPlus</h3>
<div class="paragraph">
<p>MonadPlus is a complementary abstraction for Monads that support an associative binary operation, analogous to that of a
Semigroup. If the monad implements the MonadZero and MonadPlus protocols it forms a monoid.</p>
</div>
<div class="paragraph">
<p>For the Maybe type, <code>mplus</code> acts similarly to a logical OR that treats <code>Nothing</code> values as falsey.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mplus</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/mplus</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 1&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/mplus</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">2</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 1&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_monad_transformers">5.9. Monad Transformers</h3>
<div class="sect3">
<h4 id="_motivation">5.9.1. Motivation</h4>
<div class="paragraph">
<p>We can combine two functors and get a new one automatically. Given any two functors <em>a</em> and <em>b</em>,
we can implement a generic <code>fmap</code> for the type <em>a (b Any)</em>, we&#8217;ll call it fmap2:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">functor.example</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">fmap</span><span class="tok-p">]]</span>
            <span class="tok-p">[</span><span class="tok-nv">cats.builtin</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span><span class="tok-p">]]))</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">fmap2</span>
  <span class="tok-p">[</span><span class="tok-nv">f</span> <span class="tok-nv">fv</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">fmap</span> <span class="tok-p">(</span><span class="tok-nb">partial </span><span class="tok-nv">fmap</span> <span class="tok-nv">f</span><span class="tok-p">)</span> <span class="tok-nv">fv</span><span class="tok-p">))</span>

<span class="tok-c1">; Here, &#39;a&#39; is [] and &#39;b&#39; is Maybe, so the type of the</span>
<span class="tok-c1">; combined functor is a vector of Maybe values that could</span>
<span class="tok-c1">; contain a value of any type.</span>
<span class="tok-p">(</span><span class="tok-nf">fmap2</span> <span class="tok-nb">inc </span><span class="tok-p">[(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">2</span><span class="tok-p">)])</span>
<span class="tok-c1">;; =&gt; [#&lt;Just 2&gt; #&lt;Just 3&gt;]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>However, monads don&#8217;t compose as nicely as functors do. We have to actually implement
the composition ourselves.</p>
</div>
<div class="paragraph">
<p>In some circumstances we would like combine the effects of two monads into another one. We call the
resulting monad a monad transformer, which is the composition of a "base" and "inner" monad. A
monad transformer is itself a monad.</p>
</div>
</div>
<div class="sect3">
<h4 id="_using_monad_transformers">5.9.2. Using monad transformers</h4>
<div class="paragraph">
<p>Let&#8217;s combine the effects of two monads: State and Maybe. We&#8217;ll create the transformer
using State as the base monad since we want the resulting type to be a stateful computation
that may fail: <code>s &#8594; Maybe (a, s)</code>.</p>
</div>
<div class="paragraph">
<p>Almost every monad implemented in <em>cats</em> has a monad transformer for combining it with
any other monad. The transformer functions take a Monad as their argument and they
return a reified MonadTrans:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-kd">ns </span><span class="tok-nv">transformers.example</span>
  <span class="tok-p">(</span><span class="tok-ss">:require</span> <span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cats.data</span> <span class="tok-ss">:as</span> <span class="tok-nv">data</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">]</span>
            <span class="tok-p">[</span><span class="tok-nv">cats.monad.state</span> <span class="tok-ss">:as</span> <span class="tok-nv">state</span><span class="tok-p">]))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">maybe-state</span>
  <span class="tok-p">(</span><span class="tok-nf">state/state-transformer</span> <span class="tok-nv">maybe/maybe-monad</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">m/with-monad</span> <span class="tok-nv">maybe-state</span>
  <span class="tok-p">(</span><span class="tok-nf">state/run-state</span> <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-mi">42</span><span class="tok-p">)</span> <span class="tok-p">{}))</span>
<span class="tok-c1">;; =&gt; #&lt;Just #&lt;Pair [42 {}]&gt;&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As we can see in the example below, the return of the <code>maybe-state</code> monad creates a stateful
function that yields a Maybe containing a pair (value, next state).</p>
</div>
<div class="paragraph">
<p>You probably noticed that we had to wrap the state function invocation with <code>cats.core/with-monad</code>.
When working with monad transformers, we have to be explicit about what monad we are using to implement
the binding policy since there is no way to distinguish values from a transformer type from those of
a regular monad.</p>
</div>
<div class="paragraph">
<p>The <code>maybe-state</code> monad combines the semantics of both State and Maybe.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_types">6. Types</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_maybe">6.1. Maybe</h3>
<div class="paragraph">
<p>This is one of the two most used monad types (also known as Optional in other programming
languages).</p>
</div>
<div class="paragraph">
<p>The Maybe monad represents encapsulation of an optional value; e.g. it is used as the return type
of functions which may or may not return a meaningful value when they are applied. It consists
of either an empty constructor (called None or Nothing), or a constructor
encapsulating the original data type A (e.g. Just A or Some A).</p>
</div>
<div class="paragraph">
<p><em>cats</em>, implements two types:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Just</code> that represents a value in a context.</p>
</li>
<li>
<p><code>Nothing</code> that represents the abscense of value.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Example creating instances of <code>Just</code> and <code>Nothing</code> types:</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Just 1&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>There are other useful functions for working with maybe monad types in the same namespace.
See the API documentation for a full list of them. But here we will explain a little relevant subset
of them.</p>
</div>
<div class="paragraph">
<p>We mentioned above that <strong>fmap</strong> extracts the value from a functor context. You will also want to
extract values wrapped by <strong>just</strong> and you can do that with <strong>from-maybe</strong>.</p>
</div>
<div class="paragraph">
<p>As we said previously, the Just or Nothing instances act like wrappers and in some circumstances
you will want extract the plain value from them. cats offers the <code>from-maybe</code> function for that.</p>
</div>
<div class="listingblock">
<div class="title">Example using <strong>from-maybe</strong> to extract values wrapped by <strong>just</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">maybe/from-maybe</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/from-maybe</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">maybe/from-maybe</span> <span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">)</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 42</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>from-maybe</code> function is a specialized version of a more generic one: <code>cats.core/extract</code>.
The generic version is a polymorphic function and will also work with different
types of different monads.</p>
</div>
<div class="paragraph">
<p>For interoperability with Clojure and ClojureScript&#8217;s <code>IDeref</code> abstraction, maybe values are
derrefable.</p>
</div>
<div class="listingblock">
<div class="title">Example using <strong>deref</strong> to extract values wrapped by <strong>just</strong>.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">1</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-p">(</span><span class="tok-nf">maybe/nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_either">6.2. Either</h3>
<div class="paragraph">
<p>Either is another type that represents a result of a computation, but (in contrast with maybe)
it can return some data with a failed computation result.</p>
</div>
<div class="paragraph">
<p>In <em>cats</em> it has two constructors:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(left v)</code>: represents a failure.</p>
</li>
<li>
<p><code>(right v)</code>: represents a successful result.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Usage example of <strong>Either</strong> constructors.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.either</span> <span class="tok-ss">:refer</span> <span class="tok-ss">:all</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nb">right </span><span class="tok-ss">:valid-value</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Right [:valid-value :right]&gt;</span>

<span class="tok-p">(</span><span class="tok-nb">left </span><span class="tok-s">&quot;Error message&quot;</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Either [Error message :left]&gt;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Either is also (like Maybe) a Functor, Applicative Functor and Monad.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Like Maybe, Either values can be dereferenced returning the value they contain.</p>
</div>
</div>
<div class="sect2">
<h3 id="_exception">6.3. Exception</h3>
<div class="paragraph">
<p>Also known as the Try monad, as popularized by Scala.</p>
</div>
<div class="paragraph">
<p>It represents a computation that may either result in an exception or return a successfully computed
value. Is very similar to the Either monad, but is semantically different.</p>
</div>
<div class="paragraph">
<p>It consists of two types: Success and Failure. The Success type is a simple
wrapper, like Right of the Either monad. But the Failure type is slightly different
from Left, because it always wraps an instance of Throwable (or any value in cljs since you can
throw arbitrary values in the JavaScript host).</p>
</div>
<div class="paragraph">
<p>The most common use case of this monad is to wrap third party libraries that use standard Exception
based error handling. Under normal circumstances, however, you should use Either instead.</p>
</div>
<div class="paragraph">
<p>It is an analogue of the try-catch block: it replaces try-catch&#8217;s stack-based error handling with
heap-based error handling. Instead of having an exception thrown and having to deal with it immediately
in the same thread, it disconnects the error handling and recovery.</p>
</div>
<div class="listingblock">
<div class="title">Usage example of <strong>try-on</strong> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.exception</span> <span class="tok-ss">:as</span> <span class="tok-nv">exc</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">exc/try-on</span> <span class="tok-mi">1</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Success [1]&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">exc/try-on</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Failure [#&lt;NullPointerException java.lang.NullPointerException&gt;]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>cats</em> comes with other syntactic sugar macros: <code>try-or-else</code> that returns a default value if a
computation fails, and <code>try-or-recover</code> that lets you handle the return value when executing a
function with the exception as first parameter.</p>
</div>
<div class="listingblock">
<div class="title">Usage example of <code>try-or-else</code> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">exc/try-or-else</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">)</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Success [2]&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Usage example of <code>try-or-recover</code> macro.</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">exc/try-or-recover</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">)</span>
                    <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">e</span><span class="tok-p">]</span>
                      <span class="tok-p">(</span><span class="tok-nf">cond</span>
                        <span class="tok-p">(</span><span class="tok-nb">instance? </span><span class="tok-nv">NullPointerException</span> <span class="tok-nv">e</span><span class="tok-p">)</span> <span class="tok-mi">0</span>
                        <span class="tok-ss">:else</span> <span class="tok-mi">100</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; #&lt;Success [0]&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The types defined for the Exception monad (Success and Failure) also implement the Clojure IDeref
interface, which allows library development using monadic composition without forcing a user of
that library to use or understand monads.</p>
</div>
<div class="paragraph">
<p>That is because when you dereference the failure instance, it will reraise the
enclosed exception.</p>
</div>
<div class="listingblock">
<div class="title">Example dereferencing a failure instance</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">f</span> <span class="tok-p">(</span><span class="tok-nf">exc/try-on</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-nv">nil</span><span class="tok-p">)))</span>

<span class="tok-o">@</span><span class="tok-nv">f</span>
<span class="tok-c1">;; =&gt; NullPointerException   clojure.lang.Numbers.ops (Numbers.java:961)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_validation">6.4. Validation</h3>
<div class="paragraph">
<p>The validation type is similar to the Either or Exception types except that it
doesn&#8217;t implement a Monad instance. It has two constructors: <code>ok</code> and <code>fail</code>,
representing success and failure respectively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.applicative.validation</span> <span class="tok-ss">:as</span> <span class="tok-nv">v</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">v/ok</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #&lt;Ok 42&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">v/fail</span> <span class="tok-p">[])</span>
<span class="tok-c1">;; =&gt; #&lt;Fail []&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It implements the Applicative protocol, and its intended usage is as an Applicative. Applying Validation
values together errs on the side of the failure, and applying failures together aggregates their values
using the Semigroup&#8217;s <code>mappend</code> function.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.applicative.validation</span> <span class="tok-ss">:as</span> <span class="tok-nv">v</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">v/ok</span> <span class="tok-mi">42</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">v/fail</span> <span class="tok-s">&quot;OH NOES&quot;</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Fail &quot;OH NOES&quot;&gt;</span>

<span class="tok-c1">;; Note that `&lt;*&gt;` is a variadic fapply</span>
<span class="tok-p">(</span><span class="tok-nf">m/&lt;*&gt;</span> <span class="tok-p">(</span><span class="tok-nf">v/ok</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
       <span class="tok-p">(</span><span class="tok-nf">v/fail</span> <span class="tok-p">{</span><span class="tok-ss">:foo</span> <span class="tok-s">&quot;bar&quot;</span><span class="tok-p">})</span>
       <span class="tok-p">(</span><span class="tok-nf">v/fail</span> <span class="tok-p">{</span><span class="tok-ss">:baz</span> <span class="tok-s">&quot;fubar&quot;</span><span class="tok-p">})</span>
       <span class="tok-p">(</span><span class="tok-nf">v/ok</span> <span class="tok-mi">99</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Fail {:baz &quot;fubar&quot;, :foo &quot;bar&quot;}&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_built_in_types">6.5. Built in types</h3>
<div class="paragraph">
<p>Some of the abstractions in <em>cats</em> are implemented for built-in types but you can&#8217;t use them directly. First,
you must load the <code>cats.builtin</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">])</span>
<span class="tok-c1">;; =&gt; [2 3 4 5]</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_nil">6.5.1. nil</h4>
<div class="paragraph">
<p>Given the fact that <code>nil</code> is both a value and a type, we have extended the <code>nil</code> type to be equivalent
to Maybe monad&#8217;s <code>Nothing</code>. This means that you can use <code>nil</code> as if were a <code>Just</code> instance like in the
following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:as</span> <span class="tok-nv">maybe</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">maybe/just</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
         <span class="tok-nv">y</span> <span class="tok-nv">nil</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, the <code>mlet</code> short-circuits when encountering a <code>nil</code> value.</p>
</div>
</div>
<div class="sect3">
<h4 id="_vector">6.5.2. Vector</h4>
<div class="paragraph">
<p>Clojure vectors also participate in several of the abstractions implemented in <em>cats</em>, most notably
as a monad. Compare the following <code>for</code> comprehension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">for </span><span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span>
      <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]]</span>
   <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; (4 5 6 5 6 7)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>with the equivalent using <em>mlet</em>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">]</span>
         <span class="tok-nv">y</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">]]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; [4 5 6 5 6 7]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the symmetry between <code>for</code> and <code>mlet</code>. This is not accidental, both are what is called a monad comprehension,
the difference is that <code>for</code> is limited to sequences and <code>mlet</code> can work with arbitrary monads.</p>
</div>
<div class="paragraph">
<p>Also, since <code>mlet</code> desugars into calls to the Monad&#8217;s <code>bind</code> function, its result keeps the type of the monadic values.</p>
</div>
</div>
<div class="sect3">
<h4 id="_lazy_sequences">6.5.3. Lazy sequences</h4>
<div class="paragraph">
<p>Lazy sequences implement the same abstractions as vectors with practically an identical implementation. If you don&#8217;t need
the results right away or are interested in a subset of the final results, you can use lazy sequence comprehensions.</p>
</div>
<div class="paragraph">
<p>Using <code>mlet</code> with lazy sequences yields exactly the same result as using <code>for</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mlet</span> <span class="tok-p">[</span><span class="tok-nv">x</span> <span class="tok-p">(</span><span class="tok-nf">lazy-seq</span> <span class="tok-p">[</span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">])</span>
         <span class="tok-nv">y</span> <span class="tok-p">(</span><span class="tok-nf">lazy-seq</span> <span class="tok-p">[</span><span class="tok-mi">3</span> <span class="tok-mi">4</span> <span class="tok-mi">5</span><span class="tok-p">])]</span>
  <span class="tok-p">(</span><span class="tok-nf">m/return</span> <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">x</span> <span class="tok-nv">y</span><span class="tok-p">)))</span>
<span class="tok-c1">;; =&gt; (4 5 6 5 6 7)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_set">6.5.4. Set</h4>
<div class="paragraph">
<p>Sets implement almost every abstraction in <em>cats</em>, from Semigroup to Monad.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/pure</span> <span class="tok-nv">set-monad</span> <span class="tok-mi">42</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #{42}</span>

<span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nb">inc </span><span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span> <span class="tok-mi">4</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; #{4 3 2 5}</span>

<span class="tok-p">(</span><span class="tok-nf">m/bind</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">}</span>
        <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-o">#</span><span class="tok-p">{</span><span class="tok-nv">v</span> <span class="tok-p">(</span><span class="tok-nb">inc </span><span class="tok-nv">v</span><span class="tok-p">)}))</span>
<span class="tok-c1">;; =&gt; #{1 4 3 2}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_map">6.5.5. Map</h4>
<div class="paragraph">
<p>Maps implement the <em>Semigroup</em> protocol, since we can use <code>merge</code> as their associative binary operation. Using
<code>mappend</code> on maps is a way to merge them together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">use</span> <span class="tok-ss">&#39;cats.builtin</span><span class="tok-p">)</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">m/mappend</span> <span class="tok-p">{</span><span class="tok-ss">:a</span> <span class="tok-s">&quot;A&quot;</span><span class="tok-p">}</span> <span class="tok-p">{</span><span class="tok-ss">:b</span> <span class="tok-s">&quot;B&quot;</span><span class="tok-p">})</span>
<span class="tok-c1">;; =&gt; {:a &quot;A&quot;, :b &quot;B&quot;}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Since we can consider the empty map an identity element for the <code>mappend</code> associative binary operation maps also
implement <em>Monoid</em> and the <code>mempty</code> function gives an empty map.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_complementary_libraries">6.6. Complementary libraries</h3>
<div class="paragraph">
<p>Some monads are defined as separated package to avoid additional
and unnecesary dependencies to cats. Also, there are some libraries
that build higher-level abstractions on top of what cats offers.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Channel monad: <a href="https://github.com/funcool/canal" class="bare">https://github.com/funcool/canal</a></p>
</li>
<li>
<p>Promise monad: <a href="https://github.com/funcool/promesa" class="bare">https://github.com/funcool/promesa</a></p>
</li>
<li>
<p>Concurrent data fetching: <a href="https://github.com/kachayev/muse" class="bare">https://github.com/kachayev/muse</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_higher_order_functions">7. Higher-order functions</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_curry">7.1. curry</h3>
<div class="paragraph">
<p>The first combinator that <em>cats</em> provides is a <code>curry</code> macro. Given a function, it can convert it to a curried
versions of itself. The generated function will accept parameters until all the expected parameters are given.
Let&#8217;s see some examples of a curried function in action:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">add</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried-add</span> <span class="tok-p">(</span><span class="tok-nf">m/curry</span> <span class="tok-nv">add</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">curried-add</span> <span class="tok-p">(</span><span class="tok-nf">curried-add</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nf">curried-add</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried-add</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried-add</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see above, since the original <code>add</code> has a single arity (3) and is fixed (i.e. it doesn&#8217;t accept a variable
number of arguments), the <code>curry</code> macro was able to generate a curried function with the correct number of parameters.</p>
</div>
<div class="paragraph">
<p>This doesn&#8217;t mean that functions with multiple arities or variadic arguments can&#8217;t be curried but an arity for the
curried function must be given:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">m/curry</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">curried+</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">(</span><span class="tok-nf">curried+</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried+</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-mi">2</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nb">= </span><span class="tok-p">((</span><span class="tok-nf">curried+</span> <span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-mi">3</span><span class="tok-p">)</span> <span class="tok-mi">6</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Curried functions are very useful in combination with the applicative&#8217;s <code>fapply</code> operation, since we can curry
a function and use applicatives for building up results with context-specific effects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">m/curry</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-nv">curried+</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-nv">curried+</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Nothing &gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-nv">curried+</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">nil</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span>

<span class="tok-p">(</span><span class="tok-nf">m/fapply</span> <span class="tok-p">(</span><span class="tok-nf">m/fmap</span> <span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">m/&lt;*&gt;</span> <span class="tok-p">(</span><span class="tok-nf">m/&lt;$&gt;</span> <span class="tok-nv">curried+</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_lift_m">7.2. lift-m</h3>
<div class="paragraph">
<p>The <code>lift-m</code> macro is a combinator for promoting functions that work on regular values to work on monadic values
instead. It uses the monad&#8217;s bind operation under the hood and, like <code>curry</code>, can be used without specifying arity
if the function we are lifting has a fixed and a single arity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-kd">defn </span><span class="tok-nv">add</span> <span class="tok-p">[</span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">]</span>
  <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-nv">a</span> <span class="tok-nv">b</span> <span class="tok-nv">c</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">add-m</span> <span class="tok-p">(</span><span class="tok-nf">m/lift-m</span> <span class="tok-nv">add</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; #&lt;Nothing &gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">nil</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Like with <code>curry</code>, we must provide an arity in case we are lifting a function that has multiple arities or is
variadic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">add-m</span> <span class="tok-p">(</span><span class="tok-nf">m/lift-m</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">nothing</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">; =&gt; #&lt;Nothing &gt;</span>

<span class="tok-p">(</span><span class="tok-nf">add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-nv">nil</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; nil</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can combine both <code>curry</code> and <code>lift-m</code> to get curried functions that work on monadic types using
the <code>curry-lift-m</code> macro. The arity is mandatory when using this macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.core</span> <span class="tok-ss">:as</span> <span class="tok-nv">m</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">cats.monad.maybe</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">just</span> <span class="tok-nv">nothing</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">m/curry-lift-m</span> <span class="tok-mi">3</span> <span class="tok-nv">+</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">((</span><span class="tok-nf">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span>

<span class="tok-p">((</span><span class="tok-nf">curried-add-m</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">2</span><span class="tok-p">))</span> <span class="tok-p">(</span><span class="tok-nf">just</span> <span class="tok-mi">3</span><span class="tok-p">))</span>
<span class="tok-c1">;; =&gt; #&lt;Just 6&gt;</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_faq">8. FAQ</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_what_clojure_types_implement_some_of_the_category_theory_abstractions">8.1. What Clojure types implement some of the Category Theory abstractions?</h3>
<div class="paragraph">
<p>In contrast to other similar libraries in Clojure, <em>cats</em> doesn&#8217;t intend to extend Clojure types
that don&#8217;t act like containers. For example, Clojure keywords are values but can not be containers so
they should not extend any of the previously explained protocols.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Summary of Clojure types and implemented protocols</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Implemented protocols</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sequence</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus, Foldable</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vector</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus, Foldable</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hash-set</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid, Functor, Applicative, Monad, MonadZero, MonadPlus</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">hash-map</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semigroup, Monoid</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_where_are_the_state_reader_writer_and_continuation_monads">8.2. Where are the State, Reader, Writer and Continuation monads?</h3>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_developers_guide">9. Developers Guide</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_philosophy">9.1. Philosophy</h3>
<div class="paragraph">
<p>Five most important rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Beautiful is better than ugly.</p>
</li>
<li>
<p>Explicit is better than implicit.</p>
</li>
<li>
<p>Simple is better than complex.</p>
</li>
<li>
<p>Complex is better than complicated.</p>
</li>
<li>
<p>Readability counts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All contributions to <em>cats</em> should keep these important rules in mind.</p>
</div>
</div>
<div class="sect2">
<h3 id="_contributing">9.2. Contributing</h3>
<div class="paragraph">
<p>Unlike Clojure and other Clojure contributed libraries, <em>cats</em> does not have many
restrictions for contributions. Just open an issue or pull request.</p>
</div>
</div>
<div class="sect2">
<h3 id="_source_code">9.3. Source Code</h3>
<div class="paragraph">
<p><em>cats</em> is open source and can be found on <a href="https://github.com/funcool/cats">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">git clone https://github.com/funcool/cats</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_tests">9.4. Run tests</h3>
<div class="paragraph">
<p>For running tests just execute this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">lein test</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_license">9.5. License</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">Copyright (c) 2014-2015 Andrey Antukh &lt;niwi@niwi.nz&gt;
Copyright (c) 2014-2015 Alejandro Gómez &lt;alejandro@dialelo.com&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-08-02 12:49:38 EEST
</div>
</div>
</body>
</html>