<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><title>cats.core documentation</title></head><body><header><section class="title"><h1><a href="index.html">Cats Api Documentation</a></h1></section><small>Version: 0.4.0-SNAPSHOT</small></header><section class="container"><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cats</span></div></div></li><li class="depth-2 branch"><a href="cats.builtin.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builtin</span></div></a></li><li class="depth-2 branch current"><a href="cats.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="cats.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-2"><a href="cats.monad.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>monad</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.channel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>channel</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.continuation.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>continuation</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.either.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>either</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.exception.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exception</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.identity.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>identity</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.maybe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>maybe</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.reader.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reader</span></div></a></li><li class="depth-3 branch"><a href="cats.monad.state.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>state</span></div></a></li><li class="depth-3"><a href="cats.monad.writer.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>writer</span></div></a></li><li class="depth-2"><a href="cats.protocols.html"><div class="inner"><span class="tree" style="top: -300px;"><span class="top" style="height: 309px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><section class="namespace-docs" id="content"><h2 class="anchor" id="top">cats.core</h2><div class="doc"><div class="markdown"><p>Category Theory abstractions for Clojure</p></div></div><div class="public anchor" id="var-*context*"><h3><a href="#var-*context*">*context*</a></h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-.3C.24.3E"><h3><a href="#var-.3C.24.3E">&lt;$&gt;</a></h3><div class="usage"><code>(&lt;$&gt; f)</code><code>(&lt;$&gt; f fv)</code></div><div class="doc"><div class="markdown"><p>Alias of fmap.</p></div></div></div><div class="public anchor" id="var-.3C*.3E"><h3><a href="#var-.3C*.3E">&lt;*&gt;</a></h3><div class="usage"><code>(&lt;*&gt; af av)</code><code>(&lt;*&gt; af av &amp; avs)</code></div><div class="doc"><div class="markdown"><p>Performs a Haskell-style left-associative fapply.</p></div></div></div><div class="public anchor" id="var-.3C.3D.3C"><h3><a href="#var-.3C.3D.3C">&lt;=&lt;</a></h3><div class="usage"><code>(&lt;=&lt; mg mf x)</code></div><div class="doc"><div class="markdown"><p>Right-to-left composition of monads. Same as <code>&gt;=&gt;</code> with its first two arguments flipped.</p></div></div></div><div class="public anchor" id="var-.3D.3C.3C"><h3><a href="#var-.3D.3C.3C">=&lt;&lt;</a></h3><div class="usage"><code>(=&lt;&lt; f mv)</code></div><div class="doc"><div class="markdown"><p>Same as the two argument version of <code>&gt;&gt;=</code> but with the arguments interchanged.</p></div></div></div><div class="public anchor" id="var-.3E.3D.3E"><h3><a href="#var-.3E.3D.3E">&gt;=&gt;</a></h3><div class="usage"><code>(&gt;=&gt; mf mg x)</code></div><div class="doc"><div class="markdown"><p>Left-to-right composition of monads.</p></div></div></div><div class="public anchor" id="var-.3E.3E"><h3><a href="#var-.3E.3E">&gt;&gt;</a></h3><div class="usage"><code>(&gt;&gt; mv mv&apos;)</code><code>(&gt;&gt; mv mv&apos; &amp; mvs)</code></div><div class="doc"><div class="markdown"><p>Performs a Haskell-style left-associative bind, ignoring the values produced by the monad computations.</p></div></div></div><div class="public anchor" id="var-.3E.3E.3D"><h3><a href="#var-.3E.3E.3D">&gt;&gt;=</a></h3><div class="usage"><code>(&gt;&gt;= mv f)</code><code>(&gt;&gt;= mv f &amp; fs)</code></div><div class="doc"><div class="markdown"><p>Performs a Haskell-style left-associative bind.</p><p>Example:  (&gt;&gt;= (just 1) (comp just inc) (comp just inc))  ;=&gt; #&lt;Just [3]&gt;</p></div></div></div><div class="public anchor" id="var-bind"><h3><a href="#var-bind">bind</a></h3><div class="usage"><code>(bind mv f)</code></div><div class="doc"><div class="markdown"><p>Given a value inside monadic context mv and any function, applies a function to value of mv.</p></div></div></div><div class="public anchor" id="var-errlet"><h3><a href="#var-errlet">errlet</a></h3><h4 class="type">macro</h4><div class="usage"><code>(errlet bindings &amp; body)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-fapply"><h3><a href="#var-fapply">fapply</a></h3><div class="usage"><code>(fapply af av)</code></div><div class="doc"><div class="markdown"><p>Given function inside af&rsquo;s conext and value inside av&rsquo;s context, applies the function to value and return a result wrapped in context of same type of av context.</p></div></div></div><div class="public anchor" id="var-filter"><h3><a href="#var-filter">filter</a></h3><div class="usage"><code>(filter p mv)</code></div><div class="doc"><div class="markdown"><p>Applies a predicate to a value in a <code>MonadZero</code> instance, returning the identity element when the predicate yields false.</p><p>Otherwise, returns the instance unchanged.</p>
<pre><code>(require &#39;[cats.monad.moaybe :as maybe])
(require &#39;[cats.core :as m])

(m/filter (partial &lt; 2) (maybe/just 3))
;=&gt; &lt;Just [3]&gt;

(m/filter (partial &lt; 4) (maybe/just 3))
;=&gt; &lt;Nothing&gt;
</code></pre></div></div></div><div class="public anchor" id="var-fmap"><h3><a href="#var-fmap">fmap</a></h3><div class="usage"><code>(fmap f fv)</code></div><div class="doc"><div class="markdown"><p>Apply a function f to the value inside functor&rsquo;s fv preserving the context type.</p></div></div></div><div class="public anchor" id="var-forseq"><h3><a href="#var-forseq">forseq</a></h3><div class="usage"><code>(forseq vs mf)</code></div><div class="doc"><div class="markdown"><p>Same as mapseq but with the arguments in reverse order.</p><p>(require &lsquo;[cats.monad.maybe :as maybe]) (require &rsquo;[cats.core :as m])</p><p>(m/forseq [2 3] maybe/just) ;=&gt; &lt;Just <a href="null">2 3</a>&gt;</p><p>(m/forseq [1 2]  (fn [v]  (if (odd? v)  (maybe/just v)  (maybe/nothing)))) ;=&gt; <Nothing></p></div></div></div><div class="public anchor" id="var-get-current-context"><h3><a href="#var-get-current-context">get-current-context</a></h3><div class="usage"><code>(get-current-context)</code><code>(get-current-context default)</code></div><div class="doc"><div class="markdown"><p>Get current context or obtain it from the provided instance.</p></div></div></div><div class="public anchor" id="var-get-value"><h3><a href="#var-get-value">get-value</a></h3><div class="usage"><code>(get-value v)</code></div><div class="doc"><div class="markdown"><p>Generic function for unwrap/extract the inner value of a container.</p></div></div></div><div class="public anchor" id="var-guard"><h3><a href="#var-guard">guard</a></h3><div class="usage"><code>(guard b)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-join"><h3><a href="#var-join">join</a></h3><div class="usage"><code>(join mv)</code></div><div class="doc"><div class="markdown"><p>Remove one level of monadic structure.</p></div></div></div><div class="public anchor" id="var-lift"><h3><a href="#var-lift">lift</a></h3><div class="usage"><code>(lift mv)</code><code>(lift m mv)</code></div><div class="doc"><div class="markdown"><p>Lift a value from the inner monad of a monad transformer into a value of the monad transformer.</p></div></div></div><div class="public anchor" id="var-lift-m"><h3><a href="#var-lift-m">lift-m</a></h3><h4 class="type">macro</h4><div class="usage"><code>(lift-m n f)</code></div><div class="doc"><div class="markdown"><p>Lifts a function with the given fixed number of arguments to a monadic context.</p>
<pre><code>(require &#39;[cats.monad.maybe :as maybe])
(require &#39;[cats.core :as m])

(def monad+ (m/lift-m 2 +))

(monad+ (maybe/just 1) (maybe/just 2))
;=&gt; &lt;Just [3]&gt;

(monad+ (maybe/just 1) (maybe/nothing))
;=&gt; &lt;Nothing&gt;

(monad+ [0 2 4] [1 2])
;=&gt; [1 2 3 4 5 6]
</code></pre></div></div></div><div class="public anchor" id="var-mapseq"><h3><a href="#var-mapseq">mapseq</a></h3><div class="usage"><code>(mapseq mf coll)</code></div><div class="doc"><div class="markdown"><p>Given a function that takes a value and puts it into a monadic context, map it into the given collection calling sequence on the results.</p>
<pre><code>(require &#39;[cats.monad.maybe :as maybe])
(require &#39;[cats.core :as m])

(m/mapseq maybe/just [2 3])
;=&gt; &lt;Just [[2 3]]&gt;

(m/mapseq (fn [v]
             (if (odd? v)
               (maybe/just v)
               (maybe/nothing)))
            [1 2])
;=&gt; &lt;Nothing&gt;
</code></pre></div></div></div><div class="public anchor" id="var-mlet"><h3><a href="#var-mlet">mlet</a></h3><h4 class="type">macro</h4><div class="usage"><code>(mlet bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Monad composition macro that works like clojure let. This allows much easy composition of monadic computations.</p><p>Let see one example for understand how it works, this is a code using bind for compose few number of operations:</p>
<pre><code>(bind (just 1)
      (fn [a]
        (bind (just (inc a))
              (fn [b]
                (return (* b 2))))))
;=&gt; #&lt;Just [4]&gt;
</code></pre><p>Now see how this code can be more clear if you are using mlet macro for do it:</p>
<pre><code>(mlet [a (just 1)
       b (just (inc a))]
  (return (* b 2)))
;=&gt; #&lt;Just [4]&gt;
</code></pre></div></div></div><div class="public anchor" id="var-mlet-with"><h3><a href="#var-mlet-with">mlet-with</a></h3><h4 class="type">macro</h4><div class="usage"><code>(mlet-with monad bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>A helper macro for using monad transformers, is the same as mlet but specifying the monadic context. So, instead of writing:</p>
<pre><code>(with-monad (maybe-transformer vector-monad)
  (mlet [a [(just 1) (just 2)]
         b [(just (inc a))]]
    (return (* b 2))))
;=&gt; [#&lt;Just [4]&gt; #&lt;Just [6]&gt;]
</code></pre><p>You can just write:</p>
<pre><code>(mlet-with (maybe-transformer vector-monad)
  [a [(just 1) (just 2)]
   b [(just (inc a))]]
  (return (* b 2)))
;=&gt; [#&lt;Just [4]&gt; #&lt;Just [6]&gt;]
</code></pre></div></div></div><div class="public anchor" id="var-mplus"><h3><a href="#var-mplus">mplus</a></h3><div class="usage"><code>(mplus &amp; mvs)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-mzero"><h3><a href="#var-mzero">mzero</a></h3><div class="usage"><code>(mzero)</code></div><div class="doc"><div class="markdown"></div></div></div><div class="public anchor" id="var-pure"><h3><a href="#var-pure">pure</a></h3><div class="usage"><code>(pure v)</code><code>(pure ctx v)</code></div><div class="doc"><div class="markdown"><p>Given any value v, return it wrapped in default/effect free context.</p><p>This is multiarity function that with arity pure/1 it uses the dynamic scope to resolve the current context. With <code>pure/2</code>, you can force a specific context value.</p></div></div></div><div class="public anchor" id="var-return"><h3><a href="#var-return">return</a></h3><div class="usage"><code>(return v)</code><code>(return ctx v)</code></div><div class="doc"><div class="markdown"><p>This is a monad version of pure.</p></div></div></div><div class="public anchor" id="var-sequence"><h3><a href="#var-sequence">sequence</a></h3><div class="usage"><code>(sequence mvs)</code></div><div class="doc"><div class="markdown"><p>Given a non-empty collection of monadic values, collect their values in a vector returned in the monadic context.</p>
<pre><code>(require &#39;[cats.monad.maybe :as maybe])
(require &#39;[cats.core :as m])

(m/sequence [(maybe/just 2) (maybe/just 3)])
;=&gt; &lt;Just [[2, 3]]&gt;

(m/sequence [(maybe/nothing) (maybe/just 3)])
;=&gt; &lt;Nothing&gt;
</code></pre></div></div></div><div class="public anchor" id="var-unless"><h3><a href="#var-unless">unless</a></h3><div class="usage"><code>(unless b mv)</code></div><div class="doc"><div class="markdown"><p>If the expression is false, returns the monadic value.</p><p>Otherwise, yields nil in a monadic context.</p></div></div></div><div class="public anchor" id="var-when"><h3><a href="#var-when">when</a></h3><div class="usage"><code>(when b mv)</code><code>(when ctx b mv)</code></div><div class="doc"><div class="markdown"><p>If the expression is true, returns the monadic value.</p><p>Otherwise, yields nil in a monadic context.</p></div></div></div><div class="public anchor" id="var-with-monad"><h3><a href="#var-with-monad">with-monad</a></h3><h4 class="type">macro</h4><div class="usage"><code>(with-monad ctx &amp; body)</code></div><div class="doc"><div class="markdown"><p>Set current context to specific monad.</p></div></div></div></section></section></body></html>