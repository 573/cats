<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>cats.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Cats 0.1.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cats</span></div></div></li><li class="depth-2 branch current"><a href="cats.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="cats.protocols.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>protocols</span></div></a></li><li class="depth-2"><a href="cats.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="cats.core.html#var-*m-context*"><div class="inner"><span>*m-context*</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-.3C.24.3E"><div class="inner"><span>&lt;$&gt;</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-.3C*.3E"><div class="inner"><span>&lt;*&gt;</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-.3C.3D.3C"><div class="inner"><span>&lt;=&lt;</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-.3D.3C.3C"><div class="inner"><span>=&lt;&lt;</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-.3E.3D.3E"><div class="inner"><span>&gt;=&gt;</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-.3E.3E.3D"><div class="inner"><span>&gt;&gt;=</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-bind"><div class="inner"><span>bind</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-call-cc"><div class="inner"><span>call-cc</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-eval-state"><div class="inner"><span>eval-state</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-exec-state"><div class="inner"><span>exec-state</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-fapply"><div class="inner"><span>fapply</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-filter-m"><div class="inner"><span>filter-m</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-fmap"><div class="inner"><span>fmap</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-for-m"><div class="inner"><span>for-m</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-get-state"><div class="inner"><span>get-state</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-guard"><div class="inner"><span>guard</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-join"><div class="inner"><span>join</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-lift-m"><div class="inner"><span>lift-m</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-map-m"><div class="inner"><span>map-m</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-mlet"><div class="inner"><span>mlet</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-mplus"><div class="inner"><span>mplus</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-mzero"><div class="inner"><span>mzero</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-pure"><div class="inner"><span>pure</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-put-state"><div class="inner"><span>put-state</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-return"><div class="inner"><span>return</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-run-cont"><div class="inner"><span>run-cont</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-run-state"><div class="inner"><span>run-state</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-sequence-m"><div class="inner"><span>sequence-m</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-swap-state"><div class="inner"><span>swap-state</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-when-m"><div class="inner"><span>when-m</span></div></a></li><li class="depth-1"><a href="cats.core.html#var-with-context"><div class="inner"><span>with-context</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">cats.core</h2><pre class="doc">Category Theory abstractions for Clojure
</pre><div class="public anchor" id="var-*m-context*"><h3>*m-context*</h3><div class="usage"></div><pre class="doc"></pre></div><div class="public anchor" id="var-.3C.24.3E"><h3>&lt;$&gt;</h3><div class="usage"><code>(&lt;$&gt; f)</code><code>(&lt;$&gt; f fv)</code></div><pre class="doc">Alias of fmap.
</pre></div><div class="public anchor" id="var-.3C*.3E"><h3>&lt;*&gt;</h3><div class="usage"><code>(&lt;*&gt; af av)</code><code>(&lt;*&gt; af av &amp; avs)</code></div><pre class="doc">Performs a Haskell-style left-associative fapply.
</pre></div><div class="public anchor" id="var-.3C.3D.3C"><h3>&lt;=&lt;</h3><div class="usage"><code>(&lt;=&lt; mg mf x)</code></div><pre class="doc">Right-to-left composition of monads.

Same as `&gt;=&gt;` with its first two arguments flipped.</pre></div><div class="public anchor" id="var-.3D.3C.3C"><h3>=&lt;&lt;</h3><div class="usage"><code>(=&lt;&lt; f mv)</code></div><pre class="doc">Same as the two argument version of `&gt;&gt;=` but with the
arguments interchanged.</pre></div><div class="public anchor" id="var-.3E.3D.3E"><h3>&gt;=&gt;</h3><div class="usage"><code>(&gt;=&gt; mf mg x)</code></div><pre class="doc">Left-to-right composition of monads.
</pre></div><div class="public anchor" id="var-.3E.3E.3D"><h3>&gt;&gt;=</h3><div class="usage"><code>(&gt;&gt;= mv f)</code><code>(&gt;&gt;= mv f &amp; fs)</code></div><pre class="doc">Performs a Haskell-style left-associative bind.
</pre></div><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind mv f)</code></div><pre class="doc">Given a value inside monadic context mv and any function,
applies a function to value of mv.</pre></div><div class="public anchor" id="var-call-cc"><h3>call-cc</h3><div class="usage"><code>(call-cc f)</code></div><pre class="doc"></pre></div><div class="public anchor" id="var-eval-state"><h3>eval-state</h3><div class="usage"><code>(eval-state state seed)</code></div><pre class="doc">Given a State instance, execute the
wrapped computation and return the resultant
value, ignoring the state.
Shortly, return the first value of pair instance
returned by `run-state` function.</pre></div><div class="public anchor" id="var-exec-state"><h3>exec-state</h3><div class="usage"><code>(exec-state state seed)</code></div><pre class="doc">Given a State instance, execute the
wrapped computation and return the resultant
state.
Shortly, return the second value of pair instance
returned by `run-state` function.</pre></div><div class="public anchor" id="var-fapply"><h3>fapply</h3><div class="usage"><code>(fapply af av)</code></div><pre class="doc">Given function inside af&apos;s conext and value inside
av&apos;s context, applies the function to value and return
a result wrapped in context of same type of av context.</pre></div><div class="public anchor" id="var-filter-m"><h3>filter-m</h3><div class="usage"><code>(filter-m p mv)</code></div><pre class="doc">Applies a predicate to a value in a `MonadZero` instance,
returning the identity element when the predicate yields false.

Otherwise, returns the instance unchanged.

    (require &apos;[cats.types :as t])
    (require &apos;[cats.core :as m])

    (m/filter-m (partial &lt; 2) (t/just 3))
    ;=&gt; &lt;Just [3]&gt;

    (m/filter-m (partial &lt; 4) (t/just 3))
    ;=&gt; &lt;Nothing&gt;
</pre></div><div class="public anchor" id="var-fmap"><h3>fmap</h3><div class="usage"><code>(fmap f fv)</code></div><pre class="doc">Apply a function f to the value inside functor&apos;s fv
preserving the context type.</pre></div><div class="public anchor" id="var-for-m"><h3>for-m</h3><div class="usage"><code>(for-m vs mf)</code></div><pre class="doc">Same as map-m but with the arguments in reverse order.

(require &apos;[cats.types :as t])
(require &apos;[cats.core :as m])

(m/for-m [2 3] t/just)
;=&gt; &lt;Just [[2 3]]&gt;

(m/for-m [1 2]
         (fn [v]
            (if (odd? v)
              (t/just v)
              (t/nothing))))
;=&gt; &lt;Nothing&gt;
</pre></div><div class="public anchor" id="var-get-state"><h3>get-state</h3><div class="usage"><code>(get-state)</code></div><pre class="doc">Return State instance with computation that returns
the current state.</pre></div><div class="public anchor" id="var-guard"><h3>guard</h3><div class="usage"><code>(guard b)</code></div><pre class="doc"></pre></div><div class="public anchor" id="var-join"><h3>join</h3><div class="usage"><code>(join mv)</code></div><pre class="doc">Remove one level of monadic structure.
</pre></div><div class="public anchor" id="var-lift-m"><h3>lift-m</h3><div class="usage"><code>(lift-m f)</code></div><pre class="doc">Lifts a function to a monadic context.

(require &apos;[cats.types :as t])
(require &apos;[cats.core :as m])

(def monad+ (m/lift-m +))

(monad+ (t/just 1) (t/just 2))
;=&gt; &lt;Just [3]&gt;

(monad+ (t/just 1) (t/nothing))
;=&gt; &lt;Nothing&gt;
</pre></div><div class="public anchor" id="var-map-m"><h3>map-m</h3><div class="usage"><code>(map-m mf coll)</code></div><pre class="doc">Given a function that takes a value and puts it into a
monadic context, map it into the given collection
calling sequence-m on the results.

    (require &apos;[cats.types :as t])
    (require &apos;[cats.core :as m])

    (m/map-m t/just [2 3])
    ;=&gt; &lt;Just [[2 3]]&gt;

    (m/for-m (fn [v]
                (if (odd? v)
                  (t/just v)
                  (t/nothing)))
             [1 2])
    ;=&gt; &lt;Nothing&gt;
  </pre></div><div class="public anchor" id="var-mlet"><h3>mlet</h3><h4 class="type">macro</h4><div class="usage"><code>(mlet bindings &amp; body)</code></div><pre class="doc"></pre></div><div class="public anchor" id="var-mplus"><h3>mplus</h3><div class="usage"><code>(mplus mv mv&apos;)</code></div><pre class="doc"></pre></div><div class="public anchor" id="var-mzero"><h3>mzero</h3><div class="usage"><code>(mzero)</code></div><pre class="doc"></pre></div><div class="public anchor" id="var-pure"><h3>pure</h3><div class="usage"><code>(pure v)</code><code>(pure av v)</code></div><pre class="doc">Given any value v, return it wrapped in
default/effect free context.

This is multiarity function that with arity pure/1
it uses the dynamic scope for resolve the current
context. With pure/2, you can force specific context
value.</pre></div><div class="public anchor" id="var-put-state"><h3>put-state</h3><div class="usage"><code>(put-state newstate)</code></div><pre class="doc">Return State instance with computation that replaces
the current state with specified new state.</pre></div><div class="public anchor" id="var-return"><h3>return</h3><div class="usage"></div><pre class="doc">This is a monad version of pure.
</pre></div><div class="public anchor" id="var-run-cont"><h3>run-cont</h3><div class="usage"><code>(run-cont cont)</code></div><pre class="doc">Given a Continuation instance, execute the
wrapped computation and return its value.</pre></div><div class="public anchor" id="var-run-state"><h3>run-state</h3><div class="usage"><code>(run-state state seed)</code></div><pre class="doc">Given a State instance, execute the
wrapped computation and return Pair
instance with result and new state.

(def computation (mlet [x (get-state)
                        y (put-state (inc x))]
                   (return y)))

(def initial-state 1)
(run-state computation initial-state)

This should be return something to: #&lt;Pair [1 2]&gt;</pre></div><div class="public anchor" id="var-sequence-m"><h3>sequence-m</h3><div class="usage"><code>(sequence-m mvs)</code></div><pre class="doc">Given a non-empty collection of monadic values, collect
their values in a vector returned in the monadic context.

    (require &apos;[cats.types :as t])
    (require &apos;[cats.core :as m])

    (m/sequence-m [(t/just 2) (t/just 3)])
    ;=&gt; &lt;Just [[2, 3]]&gt;

    (m/sequence-m [(t/nothing) (t/just 3)])
    ;=&gt; &lt;Nothing&gt;
</pre></div><div class="public anchor" id="var-swap-state"><h3>swap-state</h3><div class="usage"><code>(swap-state f)</code></div><pre class="doc"></pre></div><div class="public anchor" id="var-when-m"><h3>when-m</h3><div class="usage"><code>(when-m b mv)</code></div><pre class="doc">If the expression is true, returns the monadic value.

Otherwise, yields nil in a monadic context.</pre></div><div class="public anchor" id="var-with-context"><h3>with-context</h3><h4 class="type">macro</h4><div class="usage"><code>(with-context ctx &amp; body)</code></div><pre class="doc"></pre></div></div></body></html>